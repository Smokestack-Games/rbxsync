{
  "className": "ModuleScript",
  "name": "spr",
  "referenceId": "00000009-47e4-ee29-5cc9-000011841c3f",
  "properties": {
    "Capabilities": {
      "type": "SecurityCapabilities",
      "value": 0
    },
    "LinkedSource": {
      "originalType": "ContentId",
      "type": "string",
      "value": ""
    },
    "Sandboxed": {
      "type": "bool",
      "value": false
    },
    "Source": {
      "type": "ProtectedString",
      "value": "--!strict\n---------------------------------------------------------------------\n-- spr - Spring-driven motion library\n--\n-- Copyright (c) 2023 Fractality. All rights reserved.\n-- Released under the MIT license.\n--\n-- Docs & license can be found at https://github.com/Fraktality/spr\n--\n-- API Summary:\n--\n-- spr.target(\n--    Instance obj,\n--    number dampingRatio,\n--    number undampedFrequency,\n--    dict<string, Variant> targetProperties)\n--\n--    Animates the given properties towardes the target values,\n--    given damping ratio and undamped frequency.\n--\n--\n-- spr.stop(\n--    Instance obj[,\n--    string property])\n--\n--    Stops the specified property on an Instance from animating.\n--    If no property is specified, all properties of the Instance\n--    will stop animating.\n--\n-- Visualizer: https://www.desmos.com/calculator/rzvw27ljh9\n---------------------------------------------------------------------\n\nlocal STRICT_RUNTIME_TYPES = true -- assert on parameter and property type mismatch\nlocal SLEEP_OFFSET_SQ_LIMIT = (1/3840)^2 -- square of the offset sleep limit\nlocal SLEEP_VELOCITY_SQ_LIMIT = 1e-2^2 -- square of the velocity sleep limit\nlocal SLEEP_ROTATION_OFFSET = math.rad(0.01) -- rad\nlocal SLEEP_ROTATION_VELOCITY = math.rad(0.1) -- rad/s\nlocal EPS = 1e-5 -- epsilon for stability checks around pathological frequency/damping values\nlocal AXIS_MATRIX_EPS = 1e-6 -- epsilon for converting from axis-angle to matrix\n\nlocal RunService = game:GetService(\"RunService\")\n\nlocal pi = math.pi\nlocal exp = math.exp\nlocal sin = math.sin\nlocal cos = math.cos\nlocal min = math.min\nlocal sqrt = math.sqrt\nlocal round = math.round\n\nlocal function magnitudeSq(vec: {number})\n\tlocal out = 0\n\tfor _, v in vec do\n\t\tout += v^2\n\tend\n\treturn out\nend\n\nlocal function distanceSq(vec0: {number}, vec1: {number})\n\tlocal out = 0\n\tfor i0, v0 in vec0 do\n\t\tout += (vec1[i0] - v0)^2\n\tend\n\treturn out\nend\n\ntype TypeMetadata<T> = {\n\tspringType: (dampingRatio: number, frequency: number, pos: number, typedat: TypeMetadata<T>, rawTarget: T) -> LinearSpring<T>,\n\ttoIntermediate: (T) -> {number},\n\tfromIntermediate: ({number}) -> T,\n}\n\n-- Spring for an array of linear values\nlocal LinearSpring = {}\n\ntype LinearSpring<T> = typeof(setmetatable({} :: {\n\td: number,\n\tf: number,\n\tg: {number},\n\tp: {number},\n\tv: {number},\n\ttypedat: TypeMetadata<T>,\n\trawTarget: T,\n}, LinearSpring))\n\ndo\n\tLinearSpring.__index = LinearSpring\n\n\tfunction LinearSpring.new<T>(dampingRatio: number, frequency: number, pos: T, rawGoal: T, typedat)\n\t\tlocal linearPos = typedat.toIntermediate(pos)\n\t\treturn setmetatable(\n\t\t\t{\n\t\t\t\td = dampingRatio,\n\t\t\t\tf = frequency,\n\t\t\t\tg = linearPos,\n\t\t\t\tp = linearPos,\n\t\t\t\tv = table.create(#linearPos, 0),\n\t\t\t\ttypedat = typedat,\n\t\t\t\trawGoal = rawGoal\n\t\t\t},\n\t\t\tLinearSpring\n\t\t)\n\tend\n\n\tfunction LinearSpring.setGoal<T>(self, goal: T)\n\t\tself.rawGoal = goal\n\t\tself.g = self.typedat.toIntermediate(goal)\n\tend\n\n\tfunction LinearSpring.setDampingRatio<T>(self: LinearSpring<T>, dampingRatio: number)\n\t\tself.d = dampingRatio\n\tend\n\n\tfunction LinearSpring.setFrequency<T>(self: LinearSpring<T>, frequency: number)\n\t\tself.f = frequency\n\tend\n\n\tfunction LinearSpring.canSleep<T>(self)\n\t\tif magnitudeSq(self.v) > SLEEP_VELOCITY_SQ_LIMIT then\n\t\t\treturn false\n\t\tend\n\n\t\tif distanceSq(self.p, self.g) > SLEEP_OFFSET_SQ_LIMIT then\n\t\t\treturn false\n\t\tend\n\n\t\treturn true\n\tend\n\n\tfunction LinearSpring.step<T>(self: LinearSpring<T>, dt: number)\n\t\t-- Advance the spring simulation by dt seconds.\n\t\t-- Take the damped harmonic oscillator ODE:\n\t\t--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0\n\t\t-- Where X[t] is position at time t, g is target position,\n\t\t-- f is undamped angular frequency, and d is damping ratio.\n\t\t-- Apply constant initial conditions:\n\t\t--    X[0] = p0\n\t\t--    X'[0] = v0\n\t\t-- Solve the IVP to get analytic expressions for X[t] and X'[t].\n\t\t-- The solution takes one of three forms for 0<=d<1, d=1, and d>1\n\n\t\tlocal d = self.d\n\t\tlocal f = self.f*2*pi -- Hz -> Rad/s\n\t\tlocal g = self.g\n\t\tlocal p = self.p\n\t\tlocal v = self.v\n\n\t\tif d == 1 then -- critically damped\n\t\t\tlocal q = exp(-f*dt)\n\t\t\tlocal w = dt*q\n\n\t\t\tlocal c0 = q + w*f\n\t\t\tlocal c2 = q - w*f\n\t\t\tlocal c3 = w*f*f\n\n\t\t\tfor idx = 1, #p do\n\t\t\t\tlocal o = p[idx] - g[idx]\n\t\t\t\tp[idx] = o*c0 + v[idx]*w + g[idx]\n\t\t\t\tv[idx] = v[idx]*c2 - o*c3\n\t\t\tend\n\n\t\telseif d < 1 then -- underdamped\n\t\t\tlocal q = exp(-d*f*dt)\n\t\t\tlocal c = sqrt(1 - d*d)\n\n\t\t\tlocal i = cos(dt*f*c)\n\t\t\tlocal j = sin(dt*f*c)\n\n\t\t\t-- Damping ratios approaching 1 can cause division by very small numbers.\n\t\t\t-- To mitigate that, group terms around z=j/c and find an approximation for z.\n\t\t\t-- Start with the definition of z:\n\t\t\t--    z = sin(dt*f*c)/c\n\t\t\t-- Substitute a=dt*f:\n\t\t\t--    z = sin(a*c)/c\n\t\t\t-- Take the Maclaurin expansion of z with respect to c:\n\t\t\t--    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)\n\t\t\t--    z \u2248 a - (a^3*c^2)/6 + (a^5*c^4)/120\n\t\t\t-- Rewrite in Horner form:\n\t\t\t--    z \u2248 a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n\n\t\t\tlocal z\n\t\t\tif c > EPS then\n\t\t\t\tz = j/c\n\t\t\telse\n\t\t\t\tlocal a = dt*f\n\t\t\t\tz = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6\n\t\t\tend\n\n\t\t\t-- Frequencies approaching 0 present a similar problem.\n\t\t\t-- We want an approximation for y as f approaches 0, where:\n\t\t\t--    y = sin(dt*f*c)/(f*c)\n\t\t\t-- Substitute b=dt*c:\n\t\t\t--    y = sin(b*c)/b\n\t\t\t-- Now reapply the process from z.\n\n\t\t\tlocal y\n\t\t\tif f*c > EPS then\n\t\t\t\ty = j/(f*c)\n\t\t\telse\n\t\t\t\tlocal b = f*c\n\t\t\t\ty = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6\n\t\t\tend\n\n\t\t\tfor idx = 1, #p do\n\t\t\t\tlocal o = p[idx] - g[idx]\n\t\t\t\tp[idx] = (o*(i + z*d) + v[idx]*y)*q + g[idx]\n\t\t\t\tv[idx] = (v[idx]*(i - z*d) - o*(z*f))*q\n\t\t\tend\n\n\t\telse -- overdamped\n\t\t\tlocal c = sqrt(d*d - 1)\n\n\t\t\tlocal r1 = -f*(d - c)\n\t\t\tlocal r2 = -f*(d + c)\n\n\t\t\tlocal ec1 = exp(r1*dt)\n\t\t\tlocal ec2 = exp(r2*dt)\n\n\t\t\tfor idx = 1, #p do\n\t\t\t\tlocal o = p[idx] - g[idx]\n\t\t\t\tlocal co2 = (v[idx] - o*r1)/(2*f*c)\n\t\t\t\tlocal co1 = ec1*(o - co2)\n\n\t\t\t\tp[idx] = co1 + co2*ec2 + g[idx]\n\t\t\t\tv[idx] = co1*r1 + co2*ec2*r2\n\t\t\tend\n\t\tend\n\n\t\treturn self.typedat.fromIntermediate(self.p)\n\tend\nend\n\nlocal RotationSpring = {} \n\ntype RotationSpring = typeof(setmetatable({} :: {\n\td: number,\n\tf: number,\n\tg: CFrame,\n\tp: CFrame,\n\tv: Vector3,\n}, RotationSpring))\n\ndo\n\tRotationSpring.__index = RotationSpring\n\n\tlocal function angleBetween(c0: CFrame, c1: CFrame)\n\t\tlocal _, angle = (c1:ToObjectSpace(c0)):ToAxisAngle()\n\t\treturn math.abs(angle)\n\tend\n\n\tlocal function matrixToAxis(m: CFrame)\n\t\tlocal axis, angle = m:ToAxisAngle()\n\t\treturn axis*angle\n\tend\n\n\tlocal function axisToMatrix(v: Vector3)\n\t\tlocal mag = v.Magnitude\n\t\tif mag > AXIS_MATRIX_EPS then\n\t\t\treturn CFrame.fromAxisAngle(v.Unit, mag)\n\t\tend\n\t\treturn CFrame.identity\n\tend\n\n\tfunction RotationSpring.new(d: number, f: number, p: CFrame, g: CFrame)\n\t\treturn setmetatable(\n\t\t\t{\n\t\t\t\td = d,\n\t\t\t\tf = f,\n\t\t\t\tg = g,\n\t\t\t\tp = p,\n\t\t\t\tv = Vector3.zero\n\t\t\t},\n\t\t\tRotationSpring\n\t\t)\n\tend\n\n\tfunction RotationSpring.setGoal(self: RotationSpring, value: CFrame)\n\t\tself.g = value\n\tend\n\n\tfunction RotationSpring.setDampingRatio(self: RotationSpring, dampingRatio: number)\n\t\tself.d = dampingRatio\n\tend\n\n\tfunction RotationSpring.setFrequency(self: RotationSpring, frequency: number)\n\t\tself.f = frequency\n\tend\n\n\tfunction RotationSpring.canSleep(self: RotationSpring)\n\t\tlocal sleepP = angleBetween(self.p, self.g) < SLEEP_ROTATION_OFFSET\n\t\tlocal sleepV = self.v.Magnitude < SLEEP_ROTATION_VELOCITY\n\t\treturn sleepP and sleepV\n\tend\n\n\tfunction RotationSpring.step(self: RotationSpring, dt: number): CFrame\n\t\tlocal d = self.d\n\t\tlocal f = self.f*2*pi\n\t\tlocal g = self.g\n\t\tlocal p0 = self.p\n\t\tlocal v0 = self.v\n\n\t\tlocal offset = matrixToAxis(p0*g:Inverse())\n\t\tlocal decay = exp(-d*f*dt)\n\n\t\tlocal pt: CFrame\n\t\tlocal vt: Vector3\n\n\t\tif d == 1 then -- critically damped\n\t\t\tlocal w = dt*decay\n\n\t\t\tpt = axisToMatrix((offset*(1 + f*dt) + v0*dt)*decay)*g\n\t\t\tvt = (v0*(1 - dt*f) - offset*(dt*f*f))*decay\n\n\t\telseif d < 1 then -- underdamped\n\t\t\tlocal c = sqrt(1 - d*d)\n\n\t\t\tlocal i = cos(dt*f*c)\n\t\t\tlocal j = sin(dt*f*c)\n\n\t\t\tlocal y = j/(f*c)\n\t\t\tlocal z = j/c\n\n\t\t\tpt = axisToMatrix((offset*(i + z*d) + v0*y)*decay)*g\n\t\t\tvt = (v0*(i - z*d) - offset*(z*f))*decay\n\n\t\telse -- overdamped\n\t\t\tlocal c = sqrt(d*d - 1)\n\n\t\t\tlocal r1 = -f*(d - c)\n\t\t\tlocal r2 = -f*(d + c)\n\n\t\t\tlocal co2 = (v0 - offset*r1)/(2*f*c)\n\t\t\tlocal co1 = offset - co2\n\n\t\t\tlocal e1 = co1*exp(r1*dt)\n\t\t\tlocal e2 = co2*exp(r2*dt)\n\n\t\t\tpt = axisToMatrix(e1 + e2)*g\n\t\t\tvt = e1*r1 + e2*r2\n\t\tend\n\n\t\tself.p = pt\n\t\tself.v = vt\n\n\t\treturn pt\n\tend\nend\n\n-- Defined early to be used by CFrameSpring\nlocal typeMetadata_Vector3 = {\n\tspringType = LinearSpring.new,\n\n\ttoIntermediate = function(value)\n\t\treturn {value.X, value.Y, value.Z}\n\tend,\n\n\tfromIntermediate = function(value: {number})\n\t\treturn Vector3.new(value[1], value[2], value[3])\n\tend,\n}\n\n-- Encapsulates a CFrame - Separates translation from rotation\nlocal CFrameSpring = {}\ndo\n\tCFrameSpring.__index = CFrameSpring\n\n\tfunction CFrameSpring.new(\n\t\tdampingRatio: number,\n\t\tfrequency: number,\n\t\tvalueCurrent: CFrame,\n\t\tvalueGoal: CFrame,\n\t\t_: any\n\t)\n\t\treturn setmetatable(\n\t\t\t{\n\t\t\t\trawGoal = valueGoal,\n\t\t\t\t_position = LinearSpring.new(dampingRatio, frequency, valueCurrent.Position, valueGoal.Position, typeMetadata_Vector3),\n\t\t\t\t_rotation = RotationSpring.new(dampingRatio, frequency, valueCurrent.Rotation, valueGoal.Rotation)\n\t\t\t},\n\t\t\tCFrameSpring\n\t\t)\n\tend\n\n\tfunction CFrameSpring:setGoal(value: CFrame)\n\t\tself.rawGoal = value\n\t\tself._position:setGoal(value.Position)\n\t\tself._rotation:setGoal(value.Rotation)\n\tend\n\n\tfunction CFrameSpring:setDampingRatio(value: number)\n\t\tself._position:setDampingRatio(value)\n\t\tself._rotation:setDampingRatio(value)\n\tend\n\n\tfunction CFrameSpring:setFrequency(value: number)\n\t\tself._position:setFrequency(value)\n\t\tself._rotation:setFrequency(value)\n\tend\n\n\tfunction CFrameSpring:canSleep()\n\t\treturn self._position:canSleep() and self._rotation:canSleep()\n\tend\n\n\tfunction CFrameSpring:step(dt): CFrame\n\t\tlocal p: Vector3 = self._position:step(dt)\n\t\tlocal r: CFrame = self._rotation:step(dt)\n\t\treturn r + p\n\tend\nend\n\n-- Color conversions\nlocal rgbToLuv\nlocal luvToRgb\ndo\n\tlocal function inverseGammaCorrectD65(c)\n\t\treturn c < 0.0404482362771076 and c/12.92 or 0.87941546140213*(c + 0.055)^2.4\n\tend\n\n\tlocal function gammaCorrectD65(c)\n\t\treturn c < 3.1306684425e-3 and 12.92*c or 1.055*c^(1/2.4) - 0.055\n\tend\n\n\tfunction rgbToLuv(value: Color3): {number}\n\t\t-- convert RGB to a variant of cieluv space\n\t\tlocal r, g, b = value.R, value.G, value.B\n\n\t\t-- D65 sRGB inverse gamma correction\n\t\tr = inverseGammaCorrectD65(r)\n\t\tg = inverseGammaCorrectD65(g)\n\t\tb = inverseGammaCorrectD65(b)\n\n\t\t-- sRGB -> xyz\n\t\tlocal x = 0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b\n\t\tlocal y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b\n\t\tlocal z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b\n\n\t\t-- xyz -> scaled cieluv\n\t\tlocal l = y > 0.008856451679035631 and 116*y^(1/3) - 16 or 903.296296296296*y\n\n\t\tlocal u, v\n\t\tif z > 1e-14 then\n\t\t\tu = l*x/z\n\t\t\tv = l*(9*y/z - 0.46832)\n\t\telse\n\t\t\tu = -0.19783*l\n\t\t\tv = -0.46832*l\n\t\tend\n\n\t\treturn {l, u, v}\n\tend\n\n\tfunction luvToRgb(value: {number}): Color3\n\t\t-- convert back from modified cieluv to rgb space\n\t\tlocal l = value[1]\n\t\tif l < 0.0197955 then\n\t\t\treturn Color3.new(0, 0, 0)\n\t\tend\n\t\tlocal u = value[2]/l + 0.19783\n\t\tlocal v = value[3]/l + 0.46832\n\n\t\t-- cieluv -> xyz\n\t\tlocal y = (l + 16)/116\n\t\ty = y > 0.206896551724137931 and y*y*y or 0.12841854934601665*y - 0.01771290335807126\n\t\tlocal x = y*u/v\n\t\tlocal z = y*((3 - 0.75*u)/v - 5)\n\n\t\t-- xyz -> D65 sRGB\n\t\tlocal r =  7.2914074*x - 1.5372080*y - 0.4986286*z\n\t\tlocal g = -2.1800940*x + 1.8757561*y + 0.0415175*z\n\t\tlocal b =  0.1253477*x - 0.2040211*y + 1.0569959*z\n\n\t\t-- clamp minimum sRGB component\n\t\tif r < 0 and r < g and r < b then\n\t\t\tr, g, b = 0, g - r, b - r\n\t\telseif g < 0 and g < b then\n\t\t\tr, g, b = r - g, 0, b - g\n\t\telseif b < 0 then\n\t\t\tr, g, b = r - b, g - b, 0\n\t\tend\n\n\t\t-- gamma correction from D65\n\t\t-- clamp to avoid undesirable overflow wrapping behavior on certain properties (e.g. BasePart.Color)\n\t\treturn Color3.new(\n\t\t\tmin(gammaCorrectD65(r), 1),\n\t\t\tmin(gammaCorrectD65(g), 1),\n\t\t\tmin(gammaCorrectD65(b), 1)\n\t\t)\n\tend\nend\n\n-- Type definitions\n-- Transforms Roblox types into intermediate types, converting\n-- between spaces as necessary to preserve perceptual linearity\nlocal typeMetadata = {\n\tboolean = {\n\t\tspringType = LinearSpring.new,\n\n\t\ttoIntermediate = function(value)\n\t\t\treturn {value and 1 or 0}\n\t\tend,\n\n\t\tfromIntermediate = function(value)\n\t\t\treturn value[1] >= 0.5\n\t\tend,\n\t},\n\n\tnumber = {\n\t\tspringType = LinearSpring.new,\n\n\t\ttoIntermediate = function(value)\n\t\t\treturn {value}\n\t\tend,\n\n\t\tfromIntermediate = function(value)\n\t\t\treturn value[1]\n\t\tend,\n\t},\n\n\tNumberRange = {\n\t\tspringType = LinearSpring.new,\n\n\t\ttoIntermediate = function(value)\n\t\t\treturn {value.Min, value.Max}\n\t\tend,\n\n\t\tfromIntermediate = function(value)\n\t\t\treturn NumberRange.new(value[1], value[2])\n\t\tend,\n\t},\n\n\tUDim = {\n\t\tspringType = LinearSpring.new,\n\n\t\ttoIntermediate = function(value)\n\t\t\treturn {value.Scale, value.Offset}\n\t\tend,\n\n\t\tfromIntermediate = function(value: {number})\n\t\t\treturn UDim.new(value[1], round(value[2]))\n\t\tend,\n\t},\n\n\tUDim2 = {\n\t\tspringType = LinearSpring.new,\n\n\t\ttoIntermediate = function(value)\n\t\t\tlocal x = value.X\n\t\t\tlocal y = value.Y\n\t\t\treturn {x.Scale, x.Offset, y.Scale, y.Offset}\n\t\tend,\n\n\t\tfromIntermediate = function(value: {number})\n\t\t\treturn UDim2.new(value[1], round(value[2]), value[3], round(value[4]))\n\t\tend,\n\t},\n\n\tVector2 = {\n\t\tspringType = LinearSpring.new,\n\n\t\ttoIntermediate = function(value)\n\t\t\treturn {value.X, value.Y}\n\t\tend,\n\n\t\tfromIntermediate = function(value: {number})\n\t\t\treturn Vector2.new(value[1], value[2])\n\t\tend,\n\t},\n\n\tVector3 = typeMetadata_Vector3,\n\n\tColor3 = {\n\t\tspringType = LinearSpring.new,\n\t\ttoIntermediate = rgbToLuv,\n\t\tfromIntermediate = luvToRgb,\n\t},\n\n\t-- Only interpolates start and end keypoints\n\tColorSequence = {\n\t\tspringType = LinearSpring.new,\n\n\t\ttoIntermediate = function(value)\n\t\t\tlocal keypoints = value.Keypoints\n\n\t\t\tlocal luv0 = rgbToLuv(keypoints[1].Value)\n\t\t\tlocal luv1 = rgbToLuv(keypoints[#keypoints].Value)\n\n\t\t\treturn {\n\t\t\t\tluv0[1], luv0[2], luv0[3],\n\t\t\t\tluv1[1], luv1[2], luv1[3],\n\t\t\t}\n\t\tend,\n\n\t\tfromIntermediate = function(value: {})\n\t\t\treturn ColorSequence.new(\n\t\t\t\tluvToRgb{value[1], value[2], value[3]},\n\t\t\t\tluvToRgb{value[4], value[5], value[6]}\n\t\t\t)\n\t\tend,\n\t},\n\n\tCFrame = {\n\t\tspringType = CFrameSpring.new,\n\t\ttoIntermediate = error, -- custom (CFrameSpring)\n\t\tfromIntermediate = error, -- custom (CFrameSpring)\n\t}\n}\n\ntype PropertyOverride = {\n\t[string]: {\n\t\tclass: string,\n\t\tget: (any)->(),\n\t\tset: (any, any)->(),\n\t}\n}\n\nlocal PSEUDO_PROPERTIES: PropertyOverride = {\n\tPivot = {\n\t\tclass = \"PVInstance\",\n\t\tget = function(inst: PVInstance)\n\t\t\treturn inst:GetPivot()\n\t\tend,\n\t\tset = function(inst: PVInstance, value: CFrame)\n\t\t\tinst:PivotTo(value)\n\t\tend\n\t},\n\tScale = {\n\t\tclass = \"Model\",\n\t\tget = function(inst: Model)\n\t\t\treturn inst:GetScale()\n\t\tend,\n\t\tset = function(inst: Model, value: number)\n\t\t\tinst:ScaleTo(value)\n\t\tend\n\t}\n}\n\nlocal function getProperty(instance: Instance, property: string): any\n\tlocal override = PSEUDO_PROPERTIES[property]\n\tif override and instance:IsA(override.class) then\n\t\treturn override.get(instance)\n\telse\n\t\treturn (instance :: any)[property]\n\tend\nend\n\nlocal function setProperty(instance: Instance, property: string, value: unknown)\n\tlocal override = PSEUDO_PROPERTIES[property]\n\tif override and instance:IsA(override.class) then\n\t\toverride.set(instance, value)\n\telse\n\t\t(instance :: any)[property] = value\n\tend\nend\n\n-- Frame loop\nlocal springStates: {[Instance]: {[string]: any}} = {} -- {[instance] = {[property] = spring}\nlocal completedCallbacks: {[Instance]: {()->()}} = {}\n\nRunService.Heartbeat:Connect(function(dt)\n\tfor instance, state in springStates do\n\t\tfor propName, spring in state do\n\t\t\tif spring:canSleep() then\n\t\t\t\tstate[propName] = nil\n\t\t\t\tsetProperty(instance, propName, spring.rawGoal)\n\t\t\telse\n\t\t\t\tsetProperty(instance, propName, spring:step(dt))\n\t\t\tend\n\t\tend\n\n\t\tif not next(state) then\n\t\t\tspringStates[instance] = nil\n\n\t\t\t-- trigger completed callbacks when all properties finish animating\n\t\t\tlocal callbackList = completedCallbacks[instance]\n\t\t\tif callbackList then\n\t\t\t\t-- flush callback list before we run any callbacks in case\n\t\t\t\t-- one of the callbacks recursively adds another callback\n\t\t\t\tcompletedCallbacks[instance] = nil\n\n\t\t\t\tfor _, callback in callbackList do\n\t\t\t\t\ttask.spawn(callback)\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend)\n\nlocal function assertType(argNum: number, fnName: string, expectedType: string, value: unknown)\n\tif not expectedType:find(typeof(value)) then\n\t\terror(`bad argument #{argNum} to {fnName} ({expectedType} expected, got {typeof(value)})`, 3)\n\tend\nend\n\n-- API\nlocal spr = {}\n\nfunction spr.target(instance: Instance, dampingRatio: number, frequency: number, properties: {[string]: any})\n\tif STRICT_RUNTIME_TYPES then\n\t\tassertType(1, \"spr.target\", \"Instance\", instance)\n\t\tassertType(2, \"spr.target\", \"number\", dampingRatio)\n\t\tassertType(3, \"spr.target\", \"number\", frequency)\n\t\tassertType(4, \"spr.target\", \"table\", properties)\n\tend\n\n\tif dampingRatio ~= dampingRatio or dampingRatio < 0 then\n\t\terror((\"expected damping ratio >= 0; got %.2f\"):format(dampingRatio), 2)\n\tend\n\n\tif frequency ~= frequency or frequency < 0 then\n\t\terror((\"expected undamped frequency >= 0; got %.2f\"):format(frequency), 2)\n\tend\n\n\tlocal state = springStates[instance]\n\tif not state then\n\t\tstate = {}\n\t\tspringStates[instance] = state\n\tend\n\n\tfor propName, propTarget in properties do\n\t\tlocal propValue = getProperty(instance, propName)\n\n\t\tif STRICT_RUNTIME_TYPES and typeof(propTarget) ~= typeof(propValue) then\n\t\t\terror(`bad property {propName} to spr.target ({typeof(propValue)} expected, got {typeof(propTarget)})`, 2)\n\t\tend\n\n\t\t-- Special case infinite frequency for an instantaneous change\n\t\tif frequency == math.huge then\n\t\t\tsetProperty(instance, propName, propTarget)\n\t\t\tstate[propName] = nil\n\t\t\tcontinue\n\t\tend\n\n\t\tlocal spring = state[propName]\n\t\tif not spring then\n\t\t\tlocal md = typeMetadata[typeof(propTarget)]\n\t\t\tif not md then\n\t\t\t\terror(\"unsupported type: \" .. typeof(propTarget), 2)\n\t\t\tend\n\n\t\t\tspring = md.springType(dampingRatio, frequency, propValue, propTarget, md)\n\t\t\tstate[propName] = spring\n\t\tend\n\n\t\tspring:setGoal(propTarget)\n\t\tspring:setDampingRatio(dampingRatio)\n\t\tspring:setFrequency(frequency)\n\tend\n\n\tif not next(state) then\n\t\tspringStates[instance] = nil\n\tend\nend\n\nfunction spr.stop(instance: Instance, property: string?)\n\tif STRICT_RUNTIME_TYPES then\n\t\tassertType(1, \"spr.stop\", \"Instance\", instance)\n\t\tassertType(2, \"spr.stop\", \"string|nil\", property)\n\tend\n\n\tif property then\n\t\tlocal state = springStates[instance]\n\t\tif state then\n\t\t\tstate[property] = nil\n\t\tend\n\telse\n\t\tspringStates[instance] = nil\n\tend\nend\n\nfunction spr.completed(instance: Instance, callback: ()->())\n\tif STRICT_RUNTIME_TYPES then\n\t\tassertType(1, \"spr.completed\", \"Instance\", instance)\n\t\tassertType(2, \"spr.completed\", \"function\", callback)\n\tend\n\n\tlocal callbackList = completedCallbacks[instance]\n\tif callbackList then\n\t\ttable.insert(callbackList, callback)\n\telse\n\t\tcompletedCallbacks[instance] = {callback}\n\tend\nend\n\nreturn table.freeze(spr)"
    },
    "className": {
      "type": "string",
      "value": "ModuleScript"
    }
  }
}