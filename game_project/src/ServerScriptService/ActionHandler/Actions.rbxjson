{
  "className": "ModuleScript",
  "name": "Actions",
  "referenceId": "00000047-03b5-c750-595d-00003c440e6c",
  "properties": {
    "Capabilities": {
      "type": "Enum",
      "value": {
        "enumType": "SecurityCapabilities",
        "value": ""
      }
    },
    "LinkedSource": {
      "type": "Enum",
      "value": {
        "enumType": "ContentId",
        "value": ""
      }
    },
    "Source": {
      "type": "ProtectedString",
      "value": "local Actions = {}\n\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal mapData = require(ReplicatedStorage:WaitForChild(\"MapData\"))\nlocal partData = require(ReplicatedStorage:WaitForChild(\"PartData\"))\nlocal Nation = require(ReplicatedStorage.Classes:WaitForChild(\"Nation\"))\nlocal Calculate = require(script.Parent.Calculate)\nlocal ReNotify = require(game.ServerScriptService.MainModule)  -- Assuming this is the correct module ID\n\n\n\nlocal colorPart = partData.ColorPart\nlocal texturePart = partData.TexturePart\nlocal pixelData, width, height = mapData.pixelData, mapData.width, mapData.height\n\n\nlocal function getBorderColor(color)\n\treturn color:Lerp(Color3.new(0,0,0), 0.3)\nend\n\nlocal function getExpandColor(color)\n\treturn color:Lerp(Color3.new(1, 1, 1), 0.3)\nend\n\nlocal function getNeighborPixels(pixelId)\n\tlocal neighbors = {}\n\tif pixelId % width ~= 0 then neighbors.right = pixelId + 1 end\n\tif pixelId % width ~= 1 then neighbors.left = pixelId - 1 end\n\tif pixelId <= (width * (height - 1)) then neighbors.bottom = pixelId + width end\n\tif pixelId > width then neighbors.top = pixelId - width end\n\treturn neighbors\nend\n\nlocal function getAllNeighborPixels(pixelId)\n\tlocal neighbors = {}\n\t-- top\n\tif pixelId > width then\n\t\ttable.insert(neighbors, pixelId - width)\n\tend\n\n\t-- bottom\n\tif pixelId <= (width * (height - 1)) then\n\t\ttable.insert(neighbors, pixelId + width)\n\tend\n\n\t-- left\n\tif pixelId % width ~= 1 then\n\t\ttable.insert(neighbors, pixelId - 1)\n\tend\n\n\t-- right\n\tif pixelId % width ~= 0 then\n\t\ttable.insert(neighbors, pixelId + 1)\n\tend\n\n\t-- top left\n\tif pixelId > width and pixelId % width ~= 1 then\n\t\ttable.insert(neighbors, pixelId - width - 1)\n\tend\n\n\t-- top right\n\tif pixelId > width and pixelId % width ~= 0 then\n\t\ttable.insert(neighbors, pixelId - width + 1)\n\tend\n\n\t-- bottom left\n\tif pixelId <= (width * (height - 1)) and pixelId % width ~= 1 then\n\t\ttable.insert(neighbors, pixelId + width - 1)\n\tend\n\n\t-- bottom right\n\tif pixelId <= (width * (height - 1)) and pixelId % width ~= 0 then\n\t\ttable.insert(neighbors, pixelId + width + 1)\n\tend\n\n\treturn neighbors\nend\n\nlocal function getLandValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\treturn game.ReplicatedStorage.BotData[tostring(player)].Land.Value\n\telse\n\t\treturn player.leaderstats.Land.Value\n\tend\n\nend\n\nlocal function setLandValue(player, newValue)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\tif isBot then\n\t\tgame.ReplicatedStorage.BotData[tostring(player)].Land.Value = newValue\n\telse\n\t\tplayer.leaderstats.Land.Value = newValue\n\tend\nend\n\nActions.getLandValue = getLandValue\nActions.setLandVvalue = setLandValue\n\nlocal function getTroopValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\treturn game.ReplicatedStorage.BotData[tostring(player)].Troops.Value\n\telse\n\t\treturn player.leaderstats.Troops.Value\n\tend\n\nend\n\nlocal function updateLandValue(playerNation, landChange)\n\tlocal userId = playerNation.playerId\n\tlocal player = playerNation.isBot and game.ReplicatedStorage.BotData[tostring(userId)] or game.Players:GetPlayerByUserId(userId)\n\tlocal landStat = playerNation.isBot and player.Land or player.leaderstats.Land\n\n\t-- Adjust the land value safely, ensuring it never goes below zero\n\tlandStat.Value = math.max(0, landStat.Value + landChange)\nend\n\n-- HANDLES A SINGLE EXPANSION UNIT\nlocal function expandPixels(playerId, enemyId, isAttack)\n\tlocal playerNation = Nation.byPlayerId[playerId]\n\tlocal playerColor = playerNation.Color\n\tlocal borderColor = getBorderColor(playerColor)\n\tlocal expandColor = getExpandColor(playerColor)\n\tlocal newBorderPixels = {} -- Store new border pixels that are not part of the enemy territory\n\tlocal newEnemyBorderPixels = {}\n\tlocal enemyNation, enemyBorderColor\n\n\tlocal playerPixelsAdded = 0\n\tlocal enemyPixelsRemoved = 0\n\n\tif isAttack then\n\t\tenemyNation = Nation.byPlayerId[enemyId]\n\t\tenemyBorderColor = getExpandColor(enemyNation.Color)\n\t\t--\tnewBorderPixels = playerNation.borderPixels\n\tend\n\n\tfor _, pixelId in ipairs(playerNation.borderPixels) do\n\t\tif pixelData[pixelId] == playerId then\n\n\t\t\tlocal ownNeighborCount = 0\n\n\t\t\tfor direction, neighborPixel in pairs(getNeighborPixels(pixelId)) do\n\t\t\t\tlocal neighborValue = pixelData[neighborPixel]\n\t\t\t\tif neighborValue == enemyId then\n\n\t\t\t\t\t-- claim new border\n\t\t\t\t\tpixelData[neighborPixel] = playerId\n\t\t\t\t\tcolorPart(neighborPixel, expandColor)\n\t\t\t\t\tplayerPixelsAdded += 1\n\t\t\t\t\ttable.insert(newBorderPixels, neighborPixel)\n\n\t\t\t\t\t-- handle attack borders logic\n\t\t\t\t\tif isAttack then\t\n\t\t\t\t\t\tenemyPixelsRemoved += 1\n\t\t\t\t\t\t-- loop through neighbors to color new enemy border\n\t\t\t\t\t\tfor direction, enemyNeighborPixel in pairs(getNeighborPixels(neighborPixel)) do\n\t\t\t\t\t\t\tlocal neighborValue = pixelData[enemyNeighborPixel]\n\t\t\t\t\t\t\tif neighborValue == enemyId then\n\n\t\t\t\t\t\t\t\ttable.insert(newEnemyBorderPixels, enemyNeighborPixel)\n\t\t\t\t\t\t\t\tcolorPart(enemyNeighborPixel, enemyBorderColor)\n\t\t\t\t\t\t\t\t--elseif neighborValue == playerId then\n\t\t\t\t\t\t\t\t--\tcolorPart(enemyNeighborPixel, playerColor)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\n\t\t\t\t\townNeighborCount += 1\n\t\t\t\telseif neighborValue == playerId then\n\t\t\t\t\townNeighborCount += 1\n\t\t\t\tend\n\t\t\tend\n\t\t\tif ownNeighborCount < 4 then\n\t\t\t\ttable.insert(newBorderPixels, pixelId)  -- If it remains a border pixel, keep it\n\t\t\telseif pixelData[pixelId] == playerId then\n\n\t\t\t\tcolorPart(pixelId, playerColor)\n\t\t\tend\n\t\tend\n\tend\n\n\tif enemyPixelsRemoved > 0 then\n\n\t\tupdateLandValue(enemyNation, -enemyPixelsRemoved)\n\n\n\t\tfor i,v in ipairs(newEnemyBorderPixels) do\n\t\t\tif Nation.byPlayerId[playerId].isBot == false then\n\t\t\t\t--warn(\"Inserting:\", v)\n\t\t\tend\n\t\t\ttable.insert(Nation.byPlayerId[enemyId].borderPixels, v)\n\t\tend\n\tend\n\n\t-- handling land increase/decrease\n\n\tupdateLandValue(playerNation, playerPixelsAdded)\n\n\tplayerNation.borderPixels = newBorderPixels\n\treturn newBorderPixels, newEnemyBorderPixels\nend\n\n\n\n\nfunction getIndexFromPosition(x, y)\n\treturn x * width + y + 1\nend\n\nfunction getPositionFromIndex(index)\n\t--index div by width gives x, the row, the remainder is y (+1)\n\n\tlocal y = (index) % width - 1 -- x is now the column index\n\tlocal x = math.floor((index) / width) -- y is now the row index\n\treturn x, y\nend\n\nfunction bresenhamsLine(x0, y0, x1, y1)\n\tlocal dx = math.abs(x1 - x0)\n\tlocal sx = x0 < x1 and 1 or -1\n\tlocal dy = -math.abs(y1 - y0)\n\tlocal sy = y0 < y1 and 1 or -1\n\tlocal err = dx + dy\n\tlocal line = {}\n\n\twhile true do\n\t\ttable.insert(line, getIndexFromPosition(x0, y0))\n\t\tif x0 == x1 and y0 == y1 then break end\n\t\tlocal e2 = 2 * err\n\t\tif e2 >= dy then\n\t\t\terr = err + dy\n\t\t\tx0 = x0 + sx\n\t\tend\n\t\tif e2 <= dx then\n\t\t\terr = err + dx\n\t\t\ty0 = y0 + sy\n\t\tend\n\tend\n\n\treturn line\nend\n\nfunction getLinePixels(pixelIndex1, pixelIndex2)\n\tlocal x0, y0 = getPositionFromIndex(pixelIndex1)\n\t--local part = Instance.new(\"Part\")\n\t--local partClone = part:Clone()\n\t--partClone.Position =  Vector3.new(x0, 5, y0)\n\n\n\t--partClone.Parent = game.Workspace\n\n\t--local partClone2 = part:Clone()\n\tlocal x1, y1 = getPositionFromIndex(pixelIndex2)\n\n\n\t--partClone2.Position =  Vector3.new(x1, 5, y1)\n\n\t--partClone2.Parent = game.Workspace\n\n\treturn bresenhamsLine(x0, y0, x1, y1)\nend\n\nfunction areAllPixelsWater(pixelIndex1, pixelIndex2)\n\tlocal x0, y0 = getPositionFromIndex(pixelIndex1)\n\tlocal x1, y1 = getPositionFromIndex(pixelIndex2)\n\tlocal linePixels = bresenhamsLine(x0, y0, x1, y1)\n\n\t--\tprint(\"made line, doing check now\")\n\tfor i, pixelIndex in ipairs(linePixels) do\n\n\t\t--colorPart(pixelIndex, Color3.new(1, 1, 0))\n\n\t\t--print(pixelIndex)\n\t\tif pixelData[pixelIndex] ~= 1 then\n\t\t\tprint(tostring(pixelIndex) .. \" is not water\")\n\t\t\treturn false\n\t\tend\n\tend\n\n\treturn true\nend\n\n\n\n\n-- NEED TO ADD BOAT! CHECK NEIGHBORS FOR WATER AND CHECK CALCULATED PATH FROM SHORTEST POINT TO DESTINATION\n\n-- Function to check if a pixel is water\nlocal function isWaterPixel(pixelId)\n\tif pixelId == 1 then\n\t\treturn true\n\tend\n\treturn false\n\t-- Implement logic to determine if a pixel is water\n\t-- This might involve checking the pixel's type or color\nend\n\n-- Function to check if a pixel is adjacent to water\nlocal function isAdjacentToWater(pixelId)\n\tfor _, neighborPixel in getNeighborPixels(pixelId) do\n\t\tif pixelData[neighborPixel] == 1 then\n\t\t\treturn neighborPixel\n\t\tend\n\tend\n\treturn false\nend\n\nlocal function manhattanDistance(x1, y1, x2, y2)\n\treturn math.abs(x1 - x2) + math.abs(y1 - y2)\nend\n\n-- Function to find the player's closest border pixel to a given pixel\nlocal function findClosestPlayerBorder(playerNation, targetPixel)\n\tlocal closestBorderPixel = nil\n\tlocal minDistance = math.huge\n\n\tfor _, borderPixel in ipairs(playerNation.borderPixels) do\n\t\tlocal x1, y1 = getPositionFromIndex(borderPixel)\n\t\tlocal x2, y2 = getPositionFromIndex(targetPixel)\n\t\tlocal distance = manhattanDistance(x1, y1, x2, y2)\n\n\t\tif distance < minDistance and pixelData[borderPixel] == playerNation.playerId then\n\t\t\tminDistance = distance\n\t\t\tclosestBorderPixel = borderPixel\n\t\tend\n\tend\n\n\treturn closestBorderPixel\nend\n\nlocal function isBoatable(playerId, pixelId)\n\tlocal playerNation = Nation.byPlayerId[playerId]\n\tlocal playerNationSharesBorderWithWater = playerNation:SharesBordersWith(1)\n\tif not playerNationSharesBorderWithWater then return false end\n\n\tlocal borderPixels = {}\n\tlocal exhausted = {}\n\tlocal startPixel = findClosestPlayerBorder(playerNation, pixelId)\n\tlocal done = false\n\n\tlocal originalStart = startPixel\n\n\tif not isAdjacentToWater(startPixel) then\n\t\trepeat\n\t\t\tlocal neighbors = getAllNeighborPixels(startPixel)\n\t\t\tlocal count = 0\n\t\t\tfor _, neighborPixel in neighbors do\n\t\t\t\ttable.insert(exhausted, neighborPixel)\n\t\t\t\tcount += 1\n\t\t\t\tif table.find(playerNation.borderPixels, neighborPixel) and not table.find(exhausted, neighborPixel) then\n\t\t\t\t\ttable.insert(borderPixels, neighborPixel)\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\tif count == #neighbors then\n\t\t\t\tdone = true\n\t\t\tend\n\t\tuntil done == true\n\tend\n\n\t-- sort by distance from original start\n\tlocal x1, y1 = getPositionFromIndex(originalStart)\n\ttable.sort(borderPixels, function(a, b)\n\t\tlocal x2, y2 = getPositionFromIndex(a)\n\t\tlocal x3, y3 = getPositionFromIndex(b)\n\t\treturn manhattanDistance(x1, y1, x2, y2) < manhattanDistance(x1, y1, x3, y3)\n\tend)\n\n\tfor _, borderPixel in borderPixels do\n\t\tif isAdjacentToWater(borderPixel) then\n\t\t\tstartPixel = borderPixel\n\t\t\tbreak\n\t\tend\n\tend\n\n\tif not isAdjacentToWater(startPixel) then\n\t\treturn false\n\tend\n\n\tlocal endPixel = pixelId\n\tif startPixel == endPixel then return false end\n\tlocal line = getLinePixels(startPixel, endPixel)\n\n\t-- for _, pixel in line do\n\t--     partData.GetPart(pixel).Color = Color3.new(1, 0, 0)\n\t-- end\n\n\tlocal lastIndex = nil\n\tfor i, pixel in line do\n\t\tif pixelData[pixel] > 1 and pixel ~= startPixel then\n\t\t\tendPixel = pixel\n\t\t\tlastIndex = i\n\t\t\tbreak\n\t\tend\n\tend\n\n\t-- partData.GetPart(startPixel).Color = Color3.new(1, 0, 0)\n\t-- partData.GetPart(endPixel).Color = Color3.new(1, 0, 0)\n\n\tif not isAdjacentToWater(endPixel) then\n\t\tlocal neighbors = getNeighborPixels(endPixel)\n\t\tfor _, neighbor in neighbors do\n\t\t\tif pixelData[neighbor] ~= pixelData[endPixel] then continue end\n\t\t\tif isAdjacentToWater(neighbor) then\n\t\t\t\tendPixel = neighbor\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\n\n\tif not playerNationSharesBorderWithWater or not isAdjacentToWater(endPixel) then\n\t\treturn false\n\tend\n\n\tlocal foundWater = false\n\twarn(lastIndex, line, startPixel, endPixel)\n\tfor i = lastIndex, #line do\n\t\tif pixelData[line[i]] ~= 1 and foundWater == true then\n\t\t\treturn false\n\t\telseif pixelData[line[i]] == 1 then\n\t\t\tfoundWater = true\n\t\tend\n\tend\n\n\tline = getLinePixels(startPixel, endPixel)\n\n\treturn true, line, startPixel, endPixel\nend\n\nActions.isBoatable = isBoatable\n\n\n\nfunction Actions.CheckTerritoryButtons(playerId, pixelValue, pixelId)\n\tlocal gameStatus = ReplicatedStorage.Data.GameStatus.Value\n\n\tlocal actionsList = {}\n\tlocal playerNation = Nation.byPlayerId[playerId]\n\tlocal enemyNation = Nation.byPlayerId[pixelValue]\n\n\twarn(\"player nation:\", playerNation, \"enemy nation:\", enemyNation)\n\n\tif pixelValue == 2 and gameStatus == 1 then\n\t\ttable.insert(actionsList, \"Spawn\")\n\t\treturn actionsList\n\telseif pixelValue == 2 and gameStatus == 2 then\n\t\tlocal boatable, line = isBoatable(playerId, pixelId)\n\t\twarn(\"boatable:\", boatable, \"line:\", line)\n\t\tif not boatable then\n\t\t\t-- if it's not a boatable situation:\n\t\t\ttable.insert(actionsList, \"Expand\")\n\t\t\treturn actionsList\n\t\telse\n\t\t\t-- if it's a boatable situation:\n\t\t\ttable.insert(actionsList, \"Boat\")\n\t\t\treturn actionsList\n\t\tend\n\tend\n\n\tif getLandValue(game.Players:GetPlayerByUserId(playerId)) == 0 then\n\t\treturn actionsList\n\tend\n\tif pixelValue == playerId then\n\t\treturn actionsList -- Self territory\n\telseif enemyNation.Team == playerNation.Team then\n\t\ttable.insert(actionsList, \"Donate\")\n\t\treturn actionsList\n\telseif playerNation:isAlly(pixelValue) then\n\t\ttable.insert(actionsList, \"Donate\")\n\t\tif playerNation:SharesBordersWith(pixelValue) then\n\t\t\ttable.insert(actionsList, \"Attack\")\n\t\t\treturn actionsList\n\t\tend\n\telseif playerNation:SharesBordersWith(pixelValue) then\n\t\ttable.insert(actionsList, \"Attack\")\n\t\tif enemyNation.isBot == false and table.find(enemyNation.Allies, playerNation.playerId) == nil then\n\t\t\ttable.insert(actionsList, \"Ally\")\n\t\tend\n\t\treturn actionsList\n\telseif enemyNation.isBot == false and table.find(enemyNation.Allies, playerNation.playerId) == nil then\n\t\ttable.insert(actionsList, \"Ally\")\n\tend\n\n\t-- THIS IS FLAWED\n\n\t-- get closest player border pixel to selection\n\t-- draw path to selected pixel\n\t-- if water in way, prompt\n\n\tlocal startPixel = findClosestPlayerBorder(enemyNation, pixelId)\n\n\tlocal endPixel = pixelId\n\n\n\t-- CHECK FOR BOAT LOGIC\n\n\tif enemyNation:SharesBordersWith(1) or pixelValue == 2 then\n\t\t--print(tostring(enemyNation) .. \" shares border with water\")\n\n\t\tif playerNation:SharesBordersWith(1) then\n\n\t\t\t--print(tostring(playerNation) .. \" shares border with water\")\n\t\t\t--colorPart(startPixel, Color3.new(1, 0, 0))\n\n\t\t\tstartPixel = isAdjacentToWater(startPixel)\n\t\t\t-- MUST CHECK IF THE BORDER PIXEL IS ADHACENT TO WATER FIRST\n\t\t\tif startPixel then\n\t\t\t\t--\tprint(\"check1\")\n\t\t\t\tendPixel = findClosestPlayerBorder(playerNation, startPixel)\n\n\n\t\t\t\t--colorPart(startPixel, Color3.new(1, 1, 0))\n\t\t\t\t--colorPart(endPixel, Color3.new(1, 0, 0))\n\n\t\t\t\tendPixel = isAdjacentToWater(endPixel)\n\n\n\n\t\t\t\tif endPixel then\n\t\t\t\t\t--print(\"check2\")\n\t\t\t\t\t--colorPart(endPixel, Color3.new(1, 1, 0))\n\n\n\n\n\t\t\t\t\tprint(startPixel)\n\t\t\t\t\tprint(endPixel)\n\n\t\t\t\t\t-- we flip these since endPixel is player, and startPixel is enemy\n\t\t\t\t\tif areAllPixelsWater(endPixel, startPixel) then\n\t\t\t\t\t\tprint(\"ALL REQUIREMENTS SATISFIED TO SEND A BOAT\")\n\n\t\t\t\t\t\t--print(\"start \" .. tostring(startPixel))\n\t\t\t\t\t\t--print(\"end \".. tostring(endPixel))\n\n\t\t\t\t\t\t--colorPart(startPixel, Color3.new(1, 1, 0))\n\t\t\t\t\t\t--colorPart(endPixel, Color3.new(1, 1, 0))\n\n\n\t\t\t\t\t\t-- get neighbor pixel that is water?\n\n\t\t\t\t\t\t--print()\n\n\n\t\t\t\t\t\t-- i need some way to run all this logic again if the boat button is clicked\n\t\t\t\t\t\t-- we need to actually send the boat across and make it land\n\t\t\t\t\t\t-- needs to lose troops while sailing\n\t\t\t\t\t\t-- \n\t\t\t\t\t\ttable.insert(actionsList, \"Boat\")\n\n\t\t\t\t\tend\n\n\n\t\t\t\tend-- Add 'Boat' action if conditions are met\n\t\t\tend\n\n\t\tend\n\n\tend\n\n\treturn actionsList -- No actions\nend\n\n\nlocal function getPercent(playerNation)\n\tif not playerNation.isBot then\n\t\treturn math.max(0, math.min(1, game.ReplicatedStorage.Remotes.GetPercentAllocatedFunction:InvokeClient(game.Players:GetPlayerByUserId(playerNation.playerId))))\n\telse\n\t\treturn math.random(30,95)/100\n\tend\nend\n\n\n\n\n\n\n\n\n-- Spawn helpers --\n\nlocal templateTag = game.ServerStorage:WaitForChild(\"Tags\") -- Assuming this is the template\n\nlocal function createPlayerTag(playerNation)\n\tlocal tagClone = templateTag:Clone()\n\ttagClone.isBot.Value = playerNation.isBot\n\t--tagClone.Name.Value = player.Name\n\tif playerNation.isBot then\n\t\ttagClone.PlayerName.Text = \"<u>\" .. playerNation.Name .. \"</u>\" -- Assuming there's a text label for the player's name\n\telseif playerNation.Name == \"\" or playerNation.Name == nil then\n\t\t-- default to player name\n\t\tlocal playerFetch = game.Players:GetPlayerByUserId(playerNation.playerId)\n\t\ttagClone.PlayerName.Text = playerFetch.Name \n\telse\n\t\ttagClone.PlayerName.Text = playerNation.Name\n\tend\n\n\ttagClone.TroopCount.Text = \"16\" -- Default troop count\n\ttagClone.Name = playerNation.playerId\n\ttagClone.playerId.Value = playerNation.playerId\n\t-- Parent to workspace to make it visible\n\n\t-- Enabling the LocalScript inside the clone\n\tif tagClone.Script then\n\t\ttagClone.Script.Enabled = false\n\tend\n\n\ttagClone.Adornee = partData.GetPart(playerNation.borderPixels[1])\n\ttagClone.Parent = game.Workspace.Tags\n\n\ttagClone.Script.Enabled = true\n\t-- Return the clone to keep a reference if needed\n\t--return tagClone\nend\n\n\nlocal oldSpawnColors = {}\nlocal oldSpawnTextures = {}\n\nlocal function resetOldSpawn(playerNation)\n\tlocal oldSpawnId = playerNation.borderPixels[1]\n\tcolorPart(oldSpawnId, oldSpawnColors[playerNation.playerId])\n\ttexturePart(oldSpawnId, oldSpawnTextures[playerNation.playerId])\n\tpixelData[oldSpawnId] = 2\n\ttable.remove(playerNation.borderPixels, 1)\nend\n\nlocal function setNewSpawn(playerNation, pixelId, borderColor)\n\tpixelData[pixelId] = playerNation.playerId\n\ttable.insert(playerNation.borderPixels, pixelId)\n\n\n\toldSpawnColors[playerNation.playerId] = partData.GetColorOfIndex(pixelId)\n\toldSpawnTextures[playerNation.playerId] = partData.GetTextureOfIndex(pixelId)\n\tcolorPart(pixelId, borderColor)\n\n\nend\n\nlocal function handleSpawn(playerNation, pixelId, isLand)\n\tlocal borderColor = getBorderColor(playerNation.Color)\n\tif isLand then\n\n\t\t-- handle leaderstats\n\t\tif playerNation.isBot then\n\t\t\t--==local player = game.ReplicatedStorage.BotData[tostring()]\n\t\t\t--if getLandValue(playerNation.playerId) > 0 then\n\t\t\t--\tresetOldSpawn(playerNation)\n\t\t\t--\tsetNewSpawn(playerNation, pixelId, borderColor)\n\t\t\t--else\n\t\t\t--updateLandValue(playerNation, 1)\n\n\t\t\tsetNewSpawn(playerNation, pixelId, borderColor)\n\n\t\t\tcreatePlayerTag(playerNation)\n\t\t\t--end\n\t\telse\n\t\t\tlocal player = game.Players:GetPlayerByUserId(playerNation.playerId)\n\t\t\t--if player:FindFirstChild(\"leaderstats\") then\n\t\t\tif getLandValue(player) > 0 then\n\t\t\t\tresetOldSpawn(playerNation)\n\t\t\t\tsetNewSpawn(playerNation, pixelId, borderColor)\n\t\t\telse\n\t\t\t\tupdateLandValue(playerNation, 1)\n\n\t\t\t\tsetNewSpawn(playerNation, pixelId, borderColor)\n\t\t\t\tcreatePlayerTag(playerNation)\n\t\t\tend\n\t\t\t--end\n\t\tend\n\n\n\tend\nend\n\n\n-- Calulate helpers\n\n-- Helper to calculate the number of pixels available for expansion\nlocal function getPixelsToConquer(playerNation)\n\tlocal pixelsToConquer = 0\n\tfor _, pixelId in ipairs(playerNation.borderPixels) do\n\t\tfor _, neighborPixel in pairs(getNeighborPixels(pixelId)) do\n\t\t\tif pixelData[neighborPixel] == 2 then\n\t\t\t\tpixelsToConquer += 1\n\t\t\tend\n\t\tend\n\tend\n\treturn pixelsToConquer\nend\n\n-- Helper to calculate the border amount for attacks\nlocal function getBorderAmount(playerNation, enemyNation)\n\tlocal borderAmount = 0\n\tfor _, pixelId in ipairs(playerNation.borderPixels) do\n\t\tif pixelData[pixelId] == playerNation.playerId then\n\t\t\t-- fixing extra border count\n\t\t\tfor _, neighborPixel in pairs(getNeighborPixels(pixelId)) do\n\t\t\t\tif pixelData[neighborPixel] == enemyNation.playerId then\n\t\t\t\t\tborderAmount += 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn borderAmount\nend\n\n\n-- update Troops\nlocal function updateTroopValue(player, newValue)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\tlocal oldTroops = game.ReplicatedStorage.BotData[tostring(player)].Troops\n\t\toldTroops.Value = math.max(0, newValue)\n\telse\n\t\tlocal oldTroops = player.leaderstats.Troops\n\t\toldTroops.Value = math.max(0, newValue)\n\tend\t\nend\n\n-- Actions\n\n\nfunction Actions.Spawn(playerId, pixelId)\n\tlocal playerNation = Nation.byPlayerId[playerId]\n\thandleSpawn(playerNation, pixelId, pixelData[pixelId] == 2)\nend\n\n\nlocal tickLength = ReplicatedStorage.Data.TickLength.Value\n\nfunction Actions.Expand(playerId, callback, ...)\n\tif callback then\n\t\tcallback( ... )\n\tend\n\n\tlocal playerNation = Nation.byPlayerId[playerId]\n\tlocal player = playerId\n\tlocal percent = getPercent(playerNation)\n\n\tif not playerNation.isBot then\n\t\tplayer = game.Players:GetPlayerByUserId(playerId)\n\tend\n\n\tlocal attackingTroops = math.floor(getTroopValue(player) * percent + .5) -- or however you calculate the initial attacking troops\n\n\t--get pixels to conquer somehow\n\n\ttask.spawn(function()\n\n\t\t-- Loop to expand while there are enough troops\n\t\tlocal newAttackerTroops = getTroopValue(player)  - attackingTroops\n\t\tupdateTroopValue(player, newAttackerTroops)\n\n\t\tlocal borderColor = getBorderColor(playerNation.Color)\n\t\tlocal expandColor = getExpandColor(playerNation.Color)\n\t\t--for i,v in playerNation.borderPixels do\n\t\t--\tif pixelData[v] == playerId then\n\t\t--\t\tcolorPart(v, expandColor)\n\t\t--\tend\n\t\t--end\n\t\tlocal newBorderPixels = {}\n\t\tlocal newEnemyBorderPixels\n\t\t--task.wait(tickLength)\n\t\tlocal expandCount = 0\n\t\t-- need to update troops first, calculate will return remaining troops\n\t\twhile attackingTroops > 0 do\n\n\t\t\tlocal newTick = tickLength\n\n\t\t\tlocal pixelsToConquer = getPixelsToConquer(playerNation)\n\n\t\t\t-- double the density (2 for empty pixels)\n\t\t\tif attackingTroops/pixelsToConquer > 2 * 2 * pixelsToConquer then\n\t\t\t\tnewTick = tickLength/2\n\t\t\tend\n\n\t\t\tif not playerNation.isBot then\n\t\t\t\tprint(\"expanding with \" .. attackingTroops .. \"against \" .. pixelsToConquer * 2)\n\n\t\t\tend\n\n\t\t\tif pixelsToConquer == 0 then\n\t\t\t\t-- still need to return troops!\n\t\t\t\tlocal expansionSuccessful, remainingTroops = Calculate.expandTerritory(player, pixelsToConquer, attackingTroops)\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tlocal expansionSuccessful, remainingTroops = Calculate.expandTerritory(player, pixelsToConquer, attackingTroops)\n\t\t\tif not expansionSuccessful then \n\t\t\t\tnewBorderPixels = playerNation.borderPixels\n\t\t\t\tfor i,v in newBorderPixels do\n\t\t\t\t\t--if pixelData[v] == playerId then\n\t\t\t\t\tcolorPart(v, borderColor)\n\t\t\t\t\t--end\n\t\t\t\tend\n\t\t\t\tif expandCount == 0 then\n\t\t\t\t\t--notify of failed expansion, not enough troops\n\t\t\t\t\tReNotify(player, \"Not enough troops to expand!\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = \"error\";\n\t\t\t\t\t\t\tTimeout = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\tend\n\t\t\t\tbreak\n\t\t\telse\n\t\t\t\texpandCount = expandCount + 1\n\t\t\tend\n\t\t\tnewBorderPixels, newEnemyBorderPixels = expandPixels(playerId, 2, false)\n\t\t\tattackingTroops = remainingTroops\n\t\t\ttask.wait(newTick)\n\n\t\tend\n\n\t\t-- recolor borders at end\n\t\t--local borderColor = getBorderColor(playerNation.Color)\n\t\t--task.wait()\n\t\tfor i,v in newBorderPixels do\n\t\t\tif pixelData[v] == playerId then\n\t\t\t\tcolorPart(v, borderColor)\n\t\t\tend\n\t\tend\n\n\tend)\n\n\nend\n\nlocal function genericAttack()\n\nend\n\nfunction Actions.Attack(playerId, callback, ...)\n\tlocal enemyId = (callback or genericAttack)( ... )\n\n\t-- warn(\"enemy id:\", enemyId)\n\n\tlocal playerNation = Nation.byPlayerId[playerId]\n\tlocal enemyNation = Nation.byPlayerId[enemyId]\n\twarn(\"enemy id:\", enemyId, enemyNation)\n\tif enemyNation == nil then return false end\n\tlocal player = playerId\n\tlocal enemy = enemyId\n\n\tlocal percent = getPercent(playerNation)\n\t-- Attack logic \n\n\tif not playerNation.isBot then\n\t\tplayer = game.Players:GetPlayerByUserId(playerId)\n\n\tend\n\tif not enemyNation.isBot then\n\t\tenemy = game.Players:GetPlayerByUserId(enemyId)\n\tend\n\n\tlocal attackingTroops = math.floor(getTroopValue(player) * percent + .5) -- or however you calculate the initial attacking troops\n\n\t--get pixels to conquer somehow\n\t--local pixelsToConquer = 1\n\t-- CALCULATE\n\n\n\ttask.spawn(function()\n\n\t\t--local newAttackerTroops = getTroopValue(player)  - attackingTroops\n\t\tupdateTroopValue(player, getTroopValue(player) - attackingTroops)\n\n\t\t-- need to update troops first, calculate will return remaining troops\n\t\tlocal borderColor = getBorderColor(playerNation.Color)\n\t\tlocal expandColor = getExpandColor(playerNation.Color)\n\t\tlocal enemyBorderColor = getBorderColor(enemyNation.Color)\n\t\t--for i,v in playerNation.borderPixels do\n\t\t--\tif pixelData[v] == playerId then\n\t\t--\t\tcolorPart(v, expandColor)\n\t\t--\tend\n\t\t--end\n\n\t\tlocal newBorderPixels = {}\n\t\tlocal newEnemyBorderPixels = {}\n\t\t--task.wait(tickLength)\n\t\tlocal newTick = tickLength\n\t\tlocal gate = true\n\n\t\tif not enemyNation.isBot then\n\t\t\tReNotify(enemy, tostring(playerNation.Name .. \" is attacking you with \" .. attackingTroops .. \" troops.\"),\n\t\t\t\t{\n\t\t\t\t\tType = \"error\";\n\t\t\t\t\tTimeout = 2;\n\t\t\t\t}\n\t\t\t)\n\t\tend\n\n\t\tif not enemyNation.isBot and table.find(enemyNation.Allies, playerNation.playerId) then\n\t\t\tReNotify(enemy, tostring(playerNation.Name .. \" has broken your alliance!\"),\n\t\t\t\t{\n\t\t\t\t\tType = \"critical\";\n\t\t\t\t\tTimeout = 5;\n\t\t\t\t}\n\t\t\t)\n\t\t\tlocal findEnemyAlly = table.find(enemyNation.Allies, playerNation.playerId)\n\t\t\tif findEnemyAlly then\n\t\t\t\ttable.remove(enemyNation.Allies, findEnemyAlly)\n\t\t\tend\n\n\t\t\tlocal findPlayerAlly = table.find(playerNation.Allies, enemyNation.playerId)\n\t\t\tif findPlayerAlly then\n\t\t\t\ttable.remove(playerNation.Allies, findPlayerAlly)\n\t\t\tend\n\t\t\t--print(enemyNation:isAlly(playerNation.playerId))\n\t\t\tlocal player1 = game.Players:GetPlayerByUserId(enemyNation.playerId)\n\t\t\tlocal player2 = game.Players:GetPlayerByUserId(playerNation.playerId)\n\t\t\tlocal remote1 = player1:FindFirstChild(\"RemoteEvent\")\n\t\t\tlocal remote2 = player2:FindFirstChild(\"RemoteEvent\")\n\t\t\tremote1:FireClient(player1, playerNation.playerId, false)\n\t\t\tremote2:FireClient(player2, enemyNation.playerId, false)\n\t\tend\n\n\t\twhile attackingTroops > 1 do\n\n\t\t\ttask.wait(newTick)\n\t\t\tlocal touchingBorderCount =  getBorderAmount(playerNation, enemyNation)\n\n\t\t\t-- double the density \n\t\t\tif attackingTroops/touchingBorderCount > 2 * Calculate.calculateBorderDensity(getTroopValue(enemy), getLandValue(enemy) ) and gate then\n\t\t\t\tgate = false\n\t\t\t\tnewTick = tickLength/2\n\t\t\tend\n\n\n\t\t\tif not playerNation.isBot then\n\t\t\t\t--warn(\"attacking nation:\", playerNation, enemyNation, touchingBorderCount, Calculate.calculateBorderDensity(getTroopValue(enemy), getLandValue(enemy) ))\t\t\t\n\t\t\t\t--print(\"attacking with \" .. attackingTroops .. \"against \" .. touchingBorderCount * Calculate.calculateBorderDensity(getTroopValue(enemy), getLandValue(enemy) ) )\n\n\t\t\tend\n\n\n\t\t\t--print(touchingBorderCount)\n\t\t\t-- UPDATE CLIENT HERE WITH THE REMAINING TROOPS, CLIENT WILL DISPLAY PERCENT BAR!\n\n\n\t\t\tlocal attackerLosses, defenderLosses, remainingTroops = Calculate.attack(player, enemy, attackingTroops, touchingBorderCount)\n\t\t\t-- fix this \n\t\t\tif attackerLosses == 0 or defenderLosses == 0 or touchingBorderCount == 0 then \n\t\t\t\tnewBorderPixels = playerNation.borderPixels\n\t\t\t\tnewEnemyBorderPixels = enemyNation.borderPixels\n\t\t\t\tfor i,v in newBorderPixels do\n\t\t\t\t\tif pixelData[v] == playerId then\n\t\t\t\t\t\tcolorPart(v, borderColor)\n\t\t\t\t\t\t--else\n\n\t\t\t\t\t\t--\tcolorPart(v, Nation.byPlayerId[pixelData[v]].Color)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tfor i,v in newEnemyBorderPixels do\n\t\t\t\t\tif pixelData[v] == enemyId then\n\t\t\t\t\t\tcolorPart(v, enemyBorderColor)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tbreak\n\t\t\tend -- if no losses, no attack happened\n\t\t\tnewBorderPixels, newEnemyBorderPixels = expandPixels(playerId, enemyId, true)\n\t\t\tattackingTroops = remainingTroops\n\n\t\tend\n\n\t\t-- recolor borders at end\n\t\t--local borderColor = getBorderColor(playerNation.Color)\n\t\t--task.wait()\n\t\tfor i,v in newBorderPixels do\n\t\t\tif pixelData[v] == playerId then\n\t\t\t\tcolorPart(v, borderColor)\n\n\t\t\tend\n\t\tend\n\t\tfor i,v in newEnemyBorderPixels do\n\t\t\tif pixelData[v] == enemyId then\n\t\t\t\tcolorPart(v, enemyBorderColor)\n\t\t\tend\n\t\tend\n\tend)\n\nend\n\n\n\n\nfunction Actions.Boat(playerId, pixelValue, pixelId)\n\tlocal playerNation = Nation.byPlayerId[playerId]\n\tlocal selectedNation = Nation.byPlayerId[pixelValue]\n\tlocal percent = getPercent(playerNation)\n\n\t-- broken check v\n\t--if playerNation:isAlly(pixelValue) and selectedNation.Team == playerNation.Team then\n\t--\treturn\n\t--end\n\n\tprint(\"check boat conditions again, then send it fam!\")\n\n\t-- get the path, get the troops, tween the color over the path\n\twarn(\"player id:\", playerId, \"pixel id:\", pixelId)\n\tlocal prevPixel = nil\n\tlocal prevColor = nil\n\tlocal boatable, line, startPixel, endPixel = isBoatable(playerId, pixelId)\n\tif boatable == true then\n\t\tlocal waterStart, waterEnd = isAdjacentToWater(startPixel), isAdjacentToWater(endPixel)\n\t\tif waterStart and waterEnd then\n\t\t\tlocal waterLine = getLinePixels(waterStart, waterEnd)\n\t\t\tfor i, pixelIndex in waterLine do\n\n\n\t\t\t\t-- sanity check\n\t\t\t\t--if pixelData[pixelIndex] ~= 1 then\n\t\t\t\t--\tprint(tostring(pixelIndex) .. \" is not water\")\n\t\t\t\t--\treturn false\n\t\t\t\t--end\n\n\t\t\t\t--set prevColor\n\n\t\t\t\t--print(partData[pixelIndex])\n\n\n\n\t\t\t\t-- color the PrevPixel to prevColor\n\t\t\t\tif prevPixel ~= nil then\n\t\t\t\t\tlocal part = partData.GetPart(prevPixel)\n\t\t\t\t\tpart.Color = prevColor\n\t\t\t\tend\n\n\t\t\t\tprevColor = partData.GetColorOfIndex(pixelIndex)\n\n\t\t\t\t-- color the Part\n\t\t\t\tcolorPart(pixelIndex, Color3.new(1, 1, 1))\n\n\n\t\t\t\tprint(\"Setting prevPixel to: \" .. tostring(pixelIndex))\n\n\t\t\t\tprevPixel = pixelIndex\n\n\t\t\t\t--colorPart(pixelIndex, Color3.new(1, 1, 1))\n\t\t\t\t--print(pixelIndex)\n\n\t\t\t\ttask.wait(tickLength)\n\n\t\t\tend\n\n\t\t\twarn(\"deploying troops from boat\")\n\t\t\tlocal returnNationId = pixelData[endPixel]\n\n\t\t\t-- Check density then create border pixel\n\t\t\t--if not (attackingTroops > (2 * Calculate.calculateBorderDensity(getTroopValue(enemy), getLandValue(enemy)))) then\n\t\t\t--\treturn\n\t\t\t--end\n\n\t\t\t-- convert targetPixel to attacker territory\n\n\t\t\tpixelData[endPixel] = playerId\n\t\t\ttable.insert(playerNation.borderPixels, endPixel)\n\n\n\t\t\tif selectedNation then\n\t\t\t\tlocal player = game.Players:GetPlayerByUserId(pixelValue)\n\t\t\t\tlocal botOrPlayer = player or pixelValue\n\t\t\t\twarn(\"set land value\")\n\t\t\t\tsetLandValue(botOrPlayer, getLandValue(botOrPlayer) - 1)\n\t\t\tend\n\n\t\t\t-- INSERT BOAT COLOR FIX IN HERE\n\t\t\ttask.spawn(function()\n\t\t\t\ttask.wait(2 * tickLength)\n\t\t\t\t-- pixelData[endPixel] = 1\n\t\t\t\t-- local find = table.find(playerNation.borderPixels, endPixel)\n\t\t\t\t-- if find then\n\t\t\t\t--     --warn(\"REMOVE\")\n\t\t\t\t--     table.remove(playerNation.borderPixels, find)\n\t\t\t\t-- end\n\n\t\t\t\tif selectedNation then\n\t\t\t\t\tlocal find2 = table.find(selectedNation.borderPixels, endPixel)\n\t\t\t\t\tif find2 then\n\t\t\t\t\t\t--warn(\"REMOVE\")\n\t\t\t\t\t\ttable.remove(selectedNation.borderPixels, find2)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif prevPixel ~= nil then\n\t\t\t\t\tlocal part = partData.GetPart(prevPixel)\n\t\t\t\t\tpart.Color = prevColor\n\t\t\t\tend\n\t\t\tend)\n\n\t\t\t--expandPixels(playerId, returnNationId, true)\n\n\t\t\t--attackingTroops -= 2 * Calculate.calculateBorderDensity(getTroopValue(enemy), getLandValue(enemy))\n\n\t\t\treturn returnNationId\n\t\tend\n\tend\nend\n\n\n\n\n-- THIS SHOULD BE HANDLED FROM THE SERVER, SO WE WILL DO THE UI PROMPT FROM HERE. ALL OTHER UI NOTIFICATIONS RUN THROUGH CLIENT SCRIPT GUIHANDLER, AND GETS REMOTES FROM THIS ACTIONS MODULE\nfunction Actions.Ally(playerId, pixelValue)\n\tlocal playerNation = Nation.byPlayerId[playerId]\n\tlocal selectedNation = Nation.byPlayerId[pixelValue]\n\n\t-- Check if the selected nation is not the same team and not a bot\n\tif not (selectedNation.Team == playerNation.Team and not selectedNation.isBot) then\n\t\tlocal recievingPlayer = game.Players:GetPlayerByUserId(selectedNation.playerId)\n\t\tlocal requestingPlayer = game.Players:GetPlayerByUserId(playerNation.playerId)\n\t\t-- Trigger the client to handle the ally request UI\n\t\tReNotify(recievingPlayer, playerNation.Name .. \" has sent you an ally request.\", {\n\t\t\tOptions = {\n\t\t\t\t{\n\t\t\t\t\tText = \"Accept\",\n\t\t\t\t\tPrimary = true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tText = \"Deny\",\n\t\t\t\t\tPrimary = false,\n\t\t\t\t}\n\t\t\t},\n\t\t\tTimeout = 10;\n\n\t\t\tCallback = function(choice)\n\t\t\t\t--print(choice)\n\t\t\t\tif choice == 1 then\n\t\t\t\t\t-- Ally if the response is Yes\n\t\t\t\t\tprint(\"Accepting Ally!\")\n\t\t\t\t\ttable.insert(playerNation.Allies, selectedNation.playerId)\n\t\t\t\t\ttable.insert(selectedNation.Allies, playerNation.playerId)\n\t\t\t\t\tReNotify(requestingPlayer, tostring(selectedNation.Name .. \" has accepted your ally request.\"),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTimeout = 5;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t\tlocal player1 = game.Players:GetPlayerByUserId(selectedNation.playerId)\n\t\t\t\t\tlocal player2 = game.Players:GetPlayerByUserId(playerNation.playerId)\n\t\t\t\t\tlocal remote1 = player1:FindFirstChild(\"RemoteEvent\")\n\t\t\t\t\tlocal remote2 = player2:FindFirstChild(\"RemoteEvent\")\n\t\t\t\t\tremote1:FireClient(player1, playerNation.playerId, true)\n\t\t\t\t\tremote2:FireClient(player2, selectedNation.playerId, true)\n\t\t\t\telse\n\t\t\t\t\tprint(\"Denying Ally!\")\n\t\t\t\tend\n\t\t\tend\n\t\t})\n\tend\nend\n\n\nfunction Actions.Donate(playerId, pixelValue)\n\tlocal playerNation = Nation.byPlayerId[playerId]\n\tlocal selectedNation = Nation.byPlayerId[pixelValue]\n\tif not playerNation:isAlly(pixelValue) and selectedNation.Team ~= playerNation.Team then\n\t\treturn\n\tend\n\tlocal percent = getPercent(playerNation)\n\n\tlocal playerSending = playerId\n\tlocal playerRecieving = pixelValue\n\tif playerNation.isBot == false then\n\t\tplayerSending = game.Players:GetPlayerByUserId(playerId)\n\tend\n\tif selectedNation.isBot == false then\n\t\tplayerRecieving = game.Players:GetPlayerByUserId(pixelValue)\n\tend\n\n\tlocal troopsToAdd = math.floor(getTroopValue(playerSending) * percent + .5)\n\n\tprint(troopsToAdd)\n\n\tupdateTroopValue(playerSending, getTroopValue(playerSending) - troopsToAdd)\n\n\tupdateTroopValue(playerRecieving, getTroopValue(playerRecieving) + troopsToAdd)\n\n\tReNotify(playerSending, tostring(\" You sent \" .. troopsToAdd .. \" troops to \" .. selectedNation.Name .. \".\"),\n\t\t{\n\t\t\tTimeout = 5;\n\t\t}\n\t)\n\n\tReNotify(playerRecieving, tostring(playerNation.Name .. \" has sent you \".. troopsToAdd .. \" troops.\"),\n\t\t{\n\t\t\tTimeout = 5;\n\t\t}\n\t)\n\n\t-- make sure you cant donate over cap limit of nation!\n\n\t-- DISPLAY IN GUIHANDLER\n\n\t-- CALCULATE\nend\n\nreturn Actions\n\n"
    }
  }
}