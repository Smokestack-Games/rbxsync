[{"className":"Script","name":"Main","properties":{"Capabilities":{"type":"Enum","value":{"enumType":"SecurityCapabilities","value":""}},"Disabled":{"type":"bool","value":false},"LinkedSource":{"type":"Enum","value":{"enumType":"ContentId","value":""}},"RunContext":{"type":"Enum","value":{"enumType":"RunContext","value":"Legacy"}},"Source":{"type":"ProtectedString","value":"-- Services and required modules\nlocal Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal DataStoreService = game:GetService(\"DataStoreService\")\n\nlocal Nation = require(ReplicatedStorage.Classes.Nation)\nlocal InitModule = require(script.Init)\nlocal Actions\nlocal Calculate = require(script.Parent.ActionHandler.Calculate)\nlocal ReNotify = require(game.ServerScriptService.MainModule)  -- Assuming this is the correct module ID\nlocal Actions\n\n-- Main Game Class\nlocal Game = {}\nGame.__index = Game\n\nlocal botTotal = 95 --270\n\nfunction Game.new()\n\tlocal self = setmetatable({}, Game)\n\tself.gameStatus = ReplicatedStorage:WaitForChild(\"Data\").GameStatus.Value\n\tself.tickLength = game.ReplicatedStorage.Data.TickLength.Value\n\tself.ticksToSpawn = game.ReplicatedStorage.Data.TicksToSpawn.Value\n\tself.loadMapGate = true\n\tself:setupEvents()\n\treturn self\nend\n\n-- Load player data from datastore\nfunction Game:loadData(player)\n\t-- Load player name and color from datastore\n\tlocal PlayerStore = DataStoreService:GetDataStore(\"PlayerPreferences\")\n\tlocal data = PlayerStore:GetAsync(player.UserId) or {}\n\treturn {\n\t\tname = data.Name or player.Name,\n\t\tcolor = (data.Color and typeof(data.Color) == \"table\" and #data.Color == 3) and Color3.new(unpack(data.Color)) or Color3.new(1,1,1),\n\t\tflag = data.Flag,\n\t\tskin = data.Skin\n\t}\nend\n\n\n-- Load test data (used in roblox studio)\nfunction Game:loadTestData()\n\tself:loadGame(\"Desert\", \"ZOMBOT\")\nend\n\n\n\n-- Asynchronously load the game mode and map\nfunction Game:loadGame(mapName, gameMode)\n\tspawn(function()\n\t\tInitModule:LoadGameMode(gameMode)\n\t\tInitModule:LoadMap(mapName)\n\t\t-- spawm 40 bots\n\t\t-- Nation needs to select spawn points, or do it from here? \n\n\t\tActions = require(script.Parent.ActionHandler.Actions)\n\n\t\tNation:createBots(botTotal)\n\t\tlocal mapDataTemp = require(ReplicatedStorage:WaitForChild(\"MapData\"))\n\t\tlocal indexTotal = mapDataTemp.width * mapDataTemp.height\n\n\t\tlocal debounce = true\n\t\twhile debounce do\n\t\t\twait(1)\n\n\t\t\tif game.ReplicatedStorage.Data.LoadProgress.Value > 62000 then\n\t\t\t\tdebounce = false\n\t\t\tend\n\t\tend\n\n\t\t-- spawn the bots in world\n\t\tfor i=1, botTotal do\n\t\t\t-- spawn needs to validate\n\t\t\tActions.Spawn(i+2, math.floor((indexTotal/botTotal) * i))\n\t\t\t--\t\t\tprint(\"spawning \" .. \"Bot\" .. i+2 .. \" at \" .. math.floor((indexTotal/botTotal) * i))\n\n\t\tend\n\n\n\n\t\tself.gameStatus = 1\n\t\tReplicatedStorage:WaitForChild(\"Data\").GameStatus.Value = 1\n\tend)\nend\n\n\n-- Initialize map data from the first player\nfunction Game:initMapDataFromFirstPlayer(player)\n\t-- Set up map and mode from first player's teleport data\n\tlocal joinData = player:GetJoinData()\n\tif not joinData.TeleportData then\n\t\tself:loadTestData() -- Test in Roblox Studio\n\t\treturn\n\tend\n\tlocal mapName = joinData.TeleportData.mapKey\n\tlocal gameMode = joinData.TeleportData.gameMode\n\tself:loadGame(mapName, gameMode)\nend\n\n\nlocal baseColors = {\n\tRed = Color3.new(1, 0, 0),\n\tBlue = Color3.new(0, 0, 1),\n\tGreen = Color3.new(0, 1, 0),\n\tYellow = Color3.new(1, 1, 0),\n\tPink = Color3.new(1, 0, 1),\n\tCyan = Color3.new(0, 1, 1),\n\tBlack = Color3.new(0.4, 0.4, 0.4),\n\tWhite = Color3.new(1, 1, 1)\n}\n\nlocal function shadeOf(color, factor)\n\treturn Color3.new(math.clamp(color.r * factor, 0, 1),\n\t\tmath.clamp(color.g * factor, 0, 1),\n\t\tmath.clamp(color.b * factor, 0, 1))\nend\n\n\n-- ... [Previous definitions remain unchanged]\nfunction Game:setupNationForPlayer(player, playerData)\n\tlocal gameMode = ReplicatedStorage.Data.Gamemode.Value\n\tlocal Teams = game.Teams\n\n\tif gameMode == \"FFA\" then\n\t\tfor _, team in pairs(Teams:GetChildren()) do\n\t\t\tif team.Name ~= \"Spectators\" and team.Name ~= \"Players\" then\n\t\t\t\t--if team.Name ~= \"Players\" then\n\t\t\t\t\tteam:Destroy()\n\t\t\t\t--end\n\t\t\tend\n\t\tend\n\t\tNation.new(false, playerData.name, playerData.color, playerData.flag, playerData.skin, player.UserId, player.UserId)\n\t\tprint(player.UserId)\n\t\tplayer.Team = Teams.Players\n\n\telseif gameMode == \"ZOMBOT\" then\n\t\tlocal teamColor = shadeOf(baseColors.White, math.random() * 0.4 + 0.8)\n\t\tNation.new(false, playerData.name, teamColor, playerData.flag, playerData.skin, player.UserId, 8)\n\t\tplayer.Team = Teams.White\n\n\t\tfor _, team in pairs(Teams:GetChildren()) do\n\t\t\tif team.Name ~= \"Black\" and team.Name ~= \"White\" and team.Name ~= \"Spectators\" then\n\t\t\t\tteam:Destroy()\n\t\t\tend\n\t\tend\n\n\telseif gameMode:sub(-3) == \"TDM\" then\n\t\tlocal maxTeams = tonumber(gameMode:sub(1, 1))\n\t\tlocal teamNames = {\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\", \"Cyan\", \"Black\", \"White\"}\n\t\tlocal index = math.random(1, maxTeams)\n\t\tlocal selectedTeamName = teamNames[index]\n\t\tlocal teamColor = shadeOf(baseColors[selectedTeamName], math.random() *.5 + .5)\n\n\t\tplayer.Team = Teams[selectedTeamName]\n\t\t\n\t\tNation.new(false, playerData.name, teamColor, playerData.flag, playerData.skin, player.UserId, index)\n\t\t\n\t\tlocal function isTeamValid(teamName)\n\t\t\tfor i = 1, maxTeams do\n\t\t\t\tif teamNames[i] == teamName then\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn false\n\t\tend\n\n\t\tfor _, team in pairs(Teams:GetChildren()) do\n\t\t\tif not isTeamValid(team.Name) and team.Name ~= \"Spectators\" then\n\t\t\t\tteam:Destroy()\n\t\t\tend\n\t\tend\n\n\telse\n\t\tprint(\"Could not parse gameMode string\")\n\tend\nend\n\n\n\n-- Make the player a spectator\nfunction Game:setupSpectator(player)\n\tlocal character = player.Character\n\tif not character then return end\n\t-- Make the character semi-transparent and disable collisions\n\tfor _, part in pairs(character:GetDescendants()) do\n\t\tif part:IsA(\"BasePart\") and part.Name ~= \"HumanoidRootPart\" then\n\t\t\tpart.Transparency = 0.7\n\t\tend\n\tend\n\tcharacter:FindFirstChildWhichIsA(\"Humanoid\"):ChangeState(Enum.HumanoidStateType.Physics)\nend\n\n-- Handle player added event\nfunction Game:playerAdded(player)\n\tif self.loadMapGate then\n\t\tself.loadMapGate = false\n\t\tself:initMapDataFromFirstPlayer(player)\n\tend\n\twhile ReplicatedStorage.Data.Gamemode.Value == \"\" do\n\t\twait()\n\tend\n\tif self.gameStatus < 2 then\n\t\tlocal playerData = self:loadData(player)\n\t\tself:setupNationForPlayer(player, playerData)\n\t\tprint(\"SetupNation!!!\")\n\t\t-- Change state of player to physics\n\t\tlocal Character = player.Character or player.CharacterAdded:Wait()\n\t\tCharacter:FindFirstChildWhichIsA(\"Humanoid\"):ChangeState(Enum.HumanoidStateType.Physics)\n\telse\n\t\tself:setupSpectator(player) -- Set the player to be a spectator.\n\tend\nend\n\n\nfunction Game:calculateOccupancy()\n\tlocal biggestNationSize = ReplicatedStorage.Data.BiggestNationSize.Value\n\tlocal mapLandSize = ReplicatedStorage.Data.MapLandSize.Value\n\n\tlocal occupancy = biggestNationSize / mapLandSize\n\n\treturn occupancy\nend\n\nlocal function getLandValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\tlocal getBotData = game.ReplicatedStorage.BotData:FindFirstChild(tostring(player))\n\t\tif getBotData then\n\t\t\treturn getBotData.Land.Value\n\t\telse\n\t\t\treturn\n\t\tend\n\telse\n\t\tif player and player:FindFirstChild(\"leaderstats\") then\n\t\t\treturn player.leaderstats.Land.Value\n\t\telse\n\t\t\treturn\n\t\tend\n\tend\n\nend\n\n\n\n\nlocal alivePlayerIds = {}\nlocal deadPlayerIds = {}\n\nlocal gameStart = false\nlocal gameOver = false\nlocal gameNotOver = false\nlocal teamNames = {\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\", \"Cyan\", \"Black\", \"White\"}\n-- handle player ticks\nfunction Game:tickMath(gameTick)\n\t\n\tlocal gamemode = ReplicatedStorage.Data.Gamemode.Value\n\t\n\tif gameStart == false then\n\t\tfor i,v in Nation.byPlayerId do\n\t\t\ttable.insert(alivePlayerIds, v.playerId)\n\t\tend\n\t\tgameStart = true\n\t\t--print(alivePlayerIds)\n\tend\n\t--local remainingNations = difference(alivePlayerIds, deadPlayerIds)\n\t--print(remainingNations)\n\t-- add troops to all Nations\n\t--print(gamemode)\n\tif gamemode == \"FFA\" and gameOver == false then\n\t\t--print(\"isFFA\")\n\t\t-- check to ensure all surviving nations are on the same ally!\n\t\tfor i, v in ipairs(alivePlayerIds) do\n\t\t\t--print(v)\n\t\t\tif i > 1 then\n\t\t\t\tif not table.find(Nation.byPlayerId[alivePlayerIds[1]].Allies, v) then\n\t\t\t\t\t--break\n\t\t\t\t\tgameNotOver = true\n\t\t\t\t\tbreak\n\t\t\t\telse --if gameNotOver == false then\n\t\t\t\t\tif i == #alivePlayerIds then\n\t\t\t\t\t\tgameOver = true\n\t\t\t\t\t\t\n\t\t\t\t\t\tprint(\"GAME OVER\")\n\t\t\t\t\t\tself.gameStatus = 3\n\t\t\t\t\t\tReplicatedStorage.Data.GameStatus.Value = 3\n\t\t\t\t\t\tReplicatedStorage.Remotes.WinEvent:FireAllClients(tostring(Nation.byPlayerId[alivePlayerIds[1]].Name))\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tgameNotOver = false\n\t\t\telseif #alivePlayerIds == 1 then\n\t\t\t\tgameOver = true\n\t\t\t\tprint(\"GAME OVER\")\n\t\t\t\tself.gameStatus = 3\n\t\t\t\tReplicatedStorage.Data.GameStatus.Value = 3\n\t\t\t\tReplicatedStorage.Remotes.WinEvent:FireAllClients(tostring(Nation.byPlayerId[alivePlayerIds[1]].Name))\n\t\t\tend\n\t\t\t\n\t\tend\n\telseif gameOver == false then -- TDM and zombot\n\t\t-- check to ensure all surviving nations are on the same team!\n\t\tfor i, v in ipairs(alivePlayerIds) do\n\t\t\tif i > 1 then\n\t\t\t\tif Nation.byPlayerId[alivePlayerIds[1]].Team ~= Nation.byPlayerId[alivePlayerIds[i]].Team then\n\t\t\t\t\t\n\t\t\t\t\tgameNotOver = true\n\t\t\t\t\tbreak\n\t\t\t\telse --if gameNotOver == false then\n\t\t\t\t\tif i == #alivePlayerIds then\n\t\t\t\t\t\tgameOver = true\n\t\t\t\t\t\tprint(\"GAME OVER\")\n\t\t\t\t\t\tself.gameStatus = 3\n\t\t\t\t\t\tReplicatedStorage.Data.GameStatus.Value = 3\n\t\t\t\t\t\tReplicatedStorage.Remotes.WinEvent:FireAllClients(teamNames[Nation.byPlayerId[alivePlayerIds[1]].Team])\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tgameNotOver = false\n\t\t\telseif #alivePlayerIds == 1 then\n\t\t\t\t-- is last\n\t\t\t\tgameOver = true\n\t\t\t\tprint(\"GAME OVER\")\n\t\t\t\tself.gameStatus = 3\n\t\t\t\tReplicatedStorage.Data.GameStatus.Value = 3\n\t\t\t\tReplicatedStorage.Remotes.WinEvent:FireAllClients(teamNames[Nation.byPlayerId[alivePlayerIds[1]].Team])\n\t\t\tend\n\n\t\tend\n\tend\n\t\n\tfor _, nation in pairs(Nation.byPlayerId) do\n\t\tlocal success, result = pcall(function()\n\n\t\t\tlocal nationId = nation.playerId\n\t\t\tlocal player = nation.playerId\n\n\t\t\tif nation.isBot == false then\n\t\t\t\tif game.Players:GetPlayerByUserId(player) then\n\t\t\t\t\tplayer = game.Players:GetPlayerByUserId(player)\n\t\t\t\telse\n\t\t\t\t--\treturn\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\t\n\n\t\t\tif getLandValue(player) == 0 and table.find(deadPlayerIds, nation.playerId) == nil then\n\t\t\t\t-- make sure it doesnt repeat this if its dead already\n\t\t\t\t-- table of dead playerIds\n\t\t\t\ttable.remove(alivePlayerIds, table.find(alivePlayerIds, nation.playerId))\n\t\t\t\ttable.insert(deadPlayerIds, nation.playerId)\n\t\t\t\t--print(deadPlayerIds)\n\t\t\t\n\t\t\t\t-- remove player tags\n\t\t\t\tfor i,player in ipairs (game.Players:GetChildren()) do\n\t\t\t\t\tReNotify(player, tostring(nation.Name .. \" has fell.\"),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = \"critical\";\n\t\t\t\t\t\t\tTimeout = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\tend\n\n\n\t\t\t\tlocal tag = game.Workspace.Tags:FindFirstChild(nationId)\n\t\t\t\tif tag then\n\t\t\t\t\ttag:Destroy()\n\t\t\t\tend\n\n\n\t\t\t\t-- Check if the player with the given userId is in the game\n\t\t\t\tif typeof(player) == \"Instance\" then\n\t\t\t\t\t--local playerObj = game.Players:GetPlayerByUserId(player)\n\n\t\t\t\t\t-- Team the player to spectators (Assuming you have a Spectators team)\n\t\t\t\t\t--local spectatorsTeam = game.Teams:FindFirstChild(\"Spectators\")\n\t\t\t\t\tplayer.Team = game:GetService(\"Teams\")[\"Spectators\"]\n\n\n\t\t\t\t\t-- Kill the player (assuming you have a function to do that)\n\t\t\t\t\tlocal function killPlayer(player)\n\t\t\t\t\t\tplayer.Character.Humanoid.Health = 0\n\t\t\t\t\t\t-- You should implement logic to handle player death here.\n\t\t\t\t\t\t-- For example, respawning the player or ending their game.\n\t\t\t\t\t\t-- This could involve setting their Humanoid's health to 0, etc.\n\t\t\t\t\tend\n\n\t\t\t\t\t-- Make the player half transparent\n\n\n\t\t\t\t\t-- Call the functions to kill and make the player half transparent\n\t\t\t\t\tkillPlayer(player)\n\t\t\t\t\tlocal playerGui = player.PlayerGui\n\t\t\t\t\tplayerGui.ExitGame.Window.Visible = true\n\t\t\t\t\t\n\t\t\t\t\t--makePlayerHalfTransparent(player)\n\n\n\n\t\t\t\tend\n\n\t\t\tend\n\n\n\n\t\t\tif gameTick % 10 == 0 then\n\t\t\t\t-- big boost\n\t\t\t\tCalculate.updateBalanceFromIncome(player)\n\t\t\telse\n\t\t\t\t-- regular interest boost\n\t\t\t\tCalculate.updateBalanceFromInterest(player)\n\t\t\tend\n\n\t\t\tCalculate.updateInterestRate(player,gameTick)\n\t\tend)\n\t\t\n\t\tif success == false then\n\t\t\twarn(\"GAME TICK ITERATION FAILED:\", result)\n\t\tend\n\tend\nend\n\n\n-- handle bot ticks\n\n-- use calculations! mirror how actionHandler handles it\nfunction Game:botAI(botId)\n\t\n\tlocal botNation = Nation.byPlayerId[botId]\n\tif botNation == nil then\n\t\twarn(\"Bot nation couldn't be found with id:\", botId, Nation.byPlayerId)\n\tend\n\t\n\t\n\t-- implement evaluation of troops and enemies to determine attack\n\t-- needs quick math to end the thread and return if it doesnt meet density requirements or something\n\t-- add in donation logic if its surrounded by friendlies\n\t-- add boat logic if surrounded by friendlies but also has water\n\t-- raycast randomly and if it can find place to go, send boat\n\t\n\t-- random agressiveness to determine what size enemy willing to attack\n\t\n\t\n\tif Calculate.botAction(botId) then\n\t\t-- Check for empty land (playerId \"2\")\n\t\tif botNation:SharesBordersWith(2) then\n\t\t\t-- \n\t\t\tActions.Expand(botId)\n\n\t\telse\n\t\t\t-- Attack a random neighbor if no empty land\n\t\t\tlocal randomEnemy, callback, pixel, pixelIndex = botNation:GetRandomEnemy()\n\t\t\t--warn(\"enemy:\", randomEnemy, \"pixel:\", pixel, \"pixel index:\", pixelIndex)\n\t\t\t-- attack from random border\n\t\t\tif randomEnemy then\n\t\t\t\tActions.Attack(botId, callback or function() return randomEnemy end, botId, pixel, pixelIndex)  -- Assuming you have an \"Attack\" function in actionsTemp\n\t\t\t\t--task.wait()\n\t\t\tend\n\t\tend\n\tend\nend\n\n\n-- CROWN UI\n\n-- Function to find the player with the most land\nfunction Game:findNationWithMostLand()\n\tlocal maxLand = 0\n\tlocal nationWithMostLand = nil\n\n\tfor _, nation in pairs(Nation.byPlayerId) do\n\t\tif #nation.borderPixels > 0 then -- Ignore dead nations\n\t\t\tlocal landValue = 0\n\t\t\tif nation.isBot == true then\n\t\t\t\t-- It's a bot, get the land value from ReplicatedStorage.BotData\n\t\t\t\tlandValue = game.ReplicatedStorage.BotData[tostring(nation.playerId)].Land.Value\n\t\t\telse\n\t\t\t\t-- It's a player, get the land value from leaderstats\n\t\t\t\tlocal player = game.Players:GetPlayerByUserId(nation.playerId)\n\t\t\t\tif player and player.leaderstats then\n\t\t\t\t\tlandValue = player.leaderstats.Land.Value\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif landValue > maxLand then\n\t\t\t\tmaxLand = landValue\n\t\t\t\tnationWithMostLand = nation.playerId\n\t\t\tend\n\t\tend\n\tend\n\n\treturn nationWithMostLand\nend\n\n\nlocal RecentCrownTag = nil\n\nlocal botGate = true\nlocal gameTicks = 0\n-- Main game loop\nfunction Game:gameLoop()\n\t--Actions = require(script.Parent.ActionHandler.Actions)\n\t--task.spawn(function()\n\t--\twhile task.wait() do\n\t--\t\ttask.wait(self.tickLength)\n\t--\t\tfor playerId, _ in Nation.byPlayerId do\n\t--\t\t\tlocal player = game.Players:GetPlayerByUserId(playerId)\n\t--\t\t\twarn(playerId, \"nation land:\", Actions.getLandValue(player or playerId))\n\t--\t\tend\n\t--\tend\n\t--end)\n\t\n\twhile task.wait(self.tickLength) do\n\t\t--local success, result = pcall(function()\n\n\t\t\tif self.gameStatus == 0 then\n\t\t\t\t--print(\"loading...\")\n\t\t\telseif self.gameStatus == 1 then\n\t\t\t\t--print(\"can spawn now... \" .. self.ticksToSpawn)\n\t\t\t\tself.ticksToSpawn = self.ticksToSpawn - 1\n\t\t\t\tgame.ReplicatedStorage.Data.TicksToSpawn.Value = game.ReplicatedStorage.Data.TicksToSpawn.Value - 1\n\t\t\t\tif self.ticksToSpawn < 1 then\n\t\t\t\t\tReplicatedStorage:WaitForChild(\"Data\").GameStatus.Value = 2\n\t\t\t\t\tself.gameStatus = 2\n\t\t\t\t\tprint(\"successfully changed gamestatus\")\n\t\t\t\tend\n\t\t\t\tprint(self.ticksToSpawn)\n\t\t\telseif self.gameStatus == 2 then\n\t\t\t\t-- add tick count\n\t\t\t\tReplicatedStorage.Data.CurrentTick.Value = ReplicatedStorage.Data.CurrentTick.Value + 1 \n\n\t\t\t\tgameTicks += 1\n\n\t\t\t\t-- \"Main loop\" If 99% occupancy, shut it down\n\t\t\t\tif self:calculateOccupancy() >= 0.99 then\n\t\t\t\t\tReplicatedStorage:WaitForChild(\"Data\").GameStatus.Value = 3\n\t\t\t\t\tself.gameStatus = 3\n\t\t\t\tend\n\n\t\t\t\t-- add troops to all nations per tick\n\t\t\t\tself:tickMath(gameTicks)\n\n\t\t\t\t-- Calculate the player with the most land\n\t\t\t\tlocal nationWithMostLand = self:findNationWithMostLand()\n\n\t\t\t\tif nationWithMostLand then\n\t\t\t\t\tif RecentCrownTag ~= nil then\n\t\t\t\t\t\tRecentCrownTag.Visible = false\n\t\t\t\t\tend\n\t\t\t\t\tgame.Workspace.Tags[nationWithMostLand].Crown.Visible = true\n\t\t\t\t\tRecentCrownTag = game.Workspace.Tags[nationWithMostLand].Crown\n\t\t\t\t\t--print(\"Player with the most land: \" .. playerWithMostLand.Name)\n\t\t\t\telse\n\t\t\t\t\t--print(\"No player found with the most land.\")\n\t\t\t\tend\n\t\t\t\t--if gameTicks % 10 == 1 then\n\t\t\t\t-- run bot AI every tick to determine if it wants to expand/attack or not\n\n\t\t\t\tfor _, nation in pairs(Nation.byPlayerId) do\n\t\t\t\t\tif nation.isBot and #nation.borderPixels > 0 then\n\t\t\t\t\t\t-- need to check if bot exists\n\n\t\t\t\t\t\t-- run bot AI to check for actions from each bot every tick\t\n\t\t\t\t\t\tself:botAI(nation.playerId)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t--end\n\n\t\t\t\t-- Add more game logic as necessary here.\n\t\t\telseif self.gameStatus == 3 then\n\t\t\t\tprint(\"round ended\")\n\t\t\t\t-- Handle end-of-round logic, such as cleanup or setting up the next round.\n\t\t\tend\n\t\t--end)\n\t\t\n\t\t--if success == false then\n\t\t--\twarn(\"GAME LOOP ITERATION FAILED:\", result)\n\t\t--end\n\tend\n\t\n\nend\n\n-- Setup player added event\nfunction Game:setupEvents()\n\t\n\tPlayers.PlayerAdded:Connect(function(player)\n\t\tplayer:LoadCharacter()\n\t\tself:playerAdded(player)\n\tend)\nend\n\n-- Run the game\nlocal gameInstance = Game.new()\ngameInstance:gameLoop()\n\n\n-- set up map and mode from first player's teleportdata\n-- set up pixel data (parent the MapData to serverscriptservice)\n\n\n\n-- changes GameStatus as it loads, so gameServer can double check client inputs, and it limits clients from sending remotes when not allowed + informs client of game state\n\n-- declare nations as people join\n-- “Main loop” If 99% occupancy, shut it down\n-- ASYNC Each tick after round starts, run addTroops\n"}},"referenceId":"00000048-61b7-4256-1cfb-00002c12f0f1","source":"-- Services and required modules\nlocal Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal DataStoreService = game:GetService(\"DataStoreService\")\n\nlocal Nation = require(ReplicatedStorage.Classes.Nation)\nlocal InitModule = require(script.Init)\nlocal Actions\nlocal Calculate = require(script.Parent.ActionHandler.Calculate)\nlocal ReNotify = require(game.ServerScriptService.MainModule)  -- Assuming this is the correct module ID\nlocal Actions\n\n-- Main Game Class\nlocal Game = {}\nGame.__index = Game\n\nlocal botTotal = 95 --270\n\nfunction Game.new()\n\tlocal self = setmetatable({}, Game)\n\tself.gameStatus = ReplicatedStorage:WaitForChild(\"Data\").GameStatus.Value\n\tself.tickLength = game.ReplicatedStorage.Data.TickLength.Value\n\tself.ticksToSpawn = game.ReplicatedStorage.Data.TicksToSpawn.Value\n\tself.loadMapGate = true\n\tself:setupEvents()\n\treturn self\nend\n\n-- Load player data from datastore\nfunction Game:loadData(player)\n\t-- Load player name and color from datastore\n\tlocal PlayerStore = DataStoreService:GetDataStore(\"PlayerPreferences\")\n\tlocal data = PlayerStore:GetAsync(player.UserId) or {}\n\treturn {\n\t\tname = data.Name or player.Name,\n\t\tcolor = (data.Color and typeof(data.Color) == \"table\" and #data.Color == 3) and Color3.new(unpack(data.Color)) or Color3.new(1,1,1),\n\t\tflag = data.Flag,\n\t\tskin = data.Skin\n\t}\nend\n\n\n-- Load test data (used in roblox studio)\nfunction Game:loadTestData()\n\tself:loadGame(\"Desert\", \"ZOMBOT\")\nend\n\n\n\n-- Asynchronously load the game mode and map\nfunction Game:loadGame(mapName, gameMode)\n\tspawn(function()\n\t\tInitModule:LoadGameMode(gameMode)\n\t\tInitModule:LoadMap(mapName)\n\t\t-- spawm 40 bots\n\t\t-- Nation needs to select spawn points, or do it from here? \n\n\t\tActions = require(script.Parent.ActionHandler.Actions)\n\n\t\tNation:createBots(botTotal)\n\t\tlocal mapDataTemp = require(ReplicatedStorage:WaitForChild(\"MapData\"))\n\t\tlocal indexTotal = mapDataTemp.width * mapDataTemp.height\n\n\t\tlocal debounce = true\n\t\twhile debounce do\n\t\t\twait(1)\n\n\t\t\tif game.ReplicatedStorage.Data.LoadProgress.Value > 62000 then\n\t\t\t\tdebounce = false\n\t\t\tend\n\t\tend\n\n\t\t-- spawn the bots in world\n\t\tfor i=1, botTotal do\n\t\t\t-- spawn needs to validate\n\t\t\tActions.Spawn(i+2, math.floor((indexTotal/botTotal) * i))\n\t\t\t--\t\t\tprint(\"spawning \" .. \"Bot\" .. i+2 .. \" at \" .. math.floor((indexTotal/botTotal) * i))\n\n\t\tend\n\n\n\n\t\tself.gameStatus = 1\n\t\tReplicatedStorage:WaitForChild(\"Data\").GameStatus.Value = 1\n\tend)\nend\n\n\n-- Initialize map data from the first player\nfunction Game:initMapDataFromFirstPlayer(player)\n\t-- Set up map and mode from first player's teleport data\n\tlocal joinData = player:GetJoinData()\n\tif not joinData.TeleportData then\n\t\tself:loadTestData() -- Test in Roblox Studio\n\t\treturn\n\tend\n\tlocal mapName = joinData.TeleportData.mapKey\n\tlocal gameMode = joinData.TeleportData.gameMode\n\tself:loadGame(mapName, gameMode)\nend\n\n\nlocal baseColors = {\n\tRed = Color3.new(1, 0, 0),\n\tBlue = Color3.new(0, 0, 1),\n\tGreen = Color3.new(0, 1, 0),\n\tYellow = Color3.new(1, 1, 0),\n\tPink = Color3.new(1, 0, 1),\n\tCyan = Color3.new(0, 1, 1),\n\tBlack = Color3.new(0.4, 0.4, 0.4),\n\tWhite = Color3.new(1, 1, 1)\n}\n\nlocal function shadeOf(color, factor)\n\treturn Color3.new(math.clamp(color.r * factor, 0, 1),\n\t\tmath.clamp(color.g * factor, 0, 1),\n\t\tmath.clamp(color.b * factor, 0, 1))\nend\n\n\n-- ... [Previous definitions remain unchanged]\nfunction Game:setupNationForPlayer(player, playerData)\n\tlocal gameMode = ReplicatedStorage.Data.Gamemode.Value\n\tlocal Teams = game.Teams\n\n\tif gameMode == \"FFA\" then\n\t\tfor _, team in pairs(Teams:GetChildren()) do\n\t\t\tif team.Name ~= \"Spectators\" and team.Name ~= \"Players\" then\n\t\t\t\t--if team.Name ~= \"Players\" then\n\t\t\t\t\tteam:Destroy()\n\t\t\t\t--end\n\t\t\tend\n\t\tend\n\t\tNation.new(false, playerData.name, playerData.color, playerData.flag, playerData.skin, player.UserId, player.UserId)\n\t\tprint(player.UserId)\n\t\tplayer.Team = Teams.Players\n\n\telseif gameMode == \"ZOMBOT\" then\n\t\tlocal teamColor = shadeOf(baseColors.White, math.random() * 0.4 + 0.8)\n\t\tNation.new(false, playerData.name, teamColor, playerData.flag, playerData.skin, player.UserId, 8)\n\t\tplayer.Team = Teams.White\n\n\t\tfor _, team in pairs(Teams:GetChildren()) do\n\t\t\tif team.Name ~= \"Black\" and team.Name ~= \"White\" and team.Name ~= \"Spectators\" then\n\t\t\t\tteam:Destroy()\n\t\t\tend\n\t\tend\n\n\telseif gameMode:sub(-3) == \"TDM\" then\n\t\tlocal maxTeams = tonumber(gameMode:sub(1, 1))\n\t\tlocal teamNames = {\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\", \"Cyan\", \"Black\", \"White\"}\n\t\tlocal index = math.random(1, maxTeams)\n\t\tlocal selectedTeamName = teamNames[index]\n\t\tlocal teamColor = shadeOf(baseColors[selectedTeamName], math.random() *.5 + .5)\n\n\t\tplayer.Team = Teams[selectedTeamName]\n\t\t\n\t\tNation.new(false, playerData.name, teamColor, playerData.flag, playerData.skin, player.UserId, index)\n\t\t\n\t\tlocal function isTeamValid(teamName)\n\t\t\tfor i = 1, maxTeams do\n\t\t\t\tif teamNames[i] == teamName then\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn false\n\t\tend\n\n\t\tfor _, team in pairs(Teams:GetChildren()) do\n\t\t\tif not isTeamValid(team.Name) and team.Name ~= \"Spectators\" then\n\t\t\t\tteam:Destroy()\n\t\t\tend\n\t\tend\n\n\telse\n\t\tprint(\"Could not parse gameMode string\")\n\tend\nend\n\n\n\n-- Make the player a spectator\nfunction Game:setupSpectator(player)\n\tlocal character = player.Character\n\tif not character then return end\n\t-- Make the character semi-transparent and disable collisions\n\tfor _, part in pairs(character:GetDescendants()) do\n\t\tif part:IsA(\"BasePart\") and part.Name ~= \"HumanoidRootPart\" then\n\t\t\tpart.Transparency = 0.7\n\t\tend\n\tend\n\tcharacter:FindFirstChildWhichIsA(\"Humanoid\"):ChangeState(Enum.HumanoidStateType.Physics)\nend\n\n-- Handle player added event\nfunction Game:playerAdded(player)\n\tif self.loadMapGate then\n\t\tself.loadMapGate = false\n\t\tself:initMapDataFromFirstPlayer(player)\n\tend\n\twhile ReplicatedStorage.Data.Gamemode.Value == \"\" do\n\t\twait()\n\tend\n\tif self.gameStatus < 2 then\n\t\tlocal playerData = self:loadData(player)\n\t\tself:setupNationForPlayer(player, playerData)\n\t\tprint(\"SetupNation!!!\")\n\t\t-- Change state of player to physics\n\t\tlocal Character = player.Character or player.CharacterAdded:Wait()\n\t\tCharacter:FindFirstChildWhichIsA(\"Humanoid\"):ChangeState(Enum.HumanoidStateType.Physics)\n\telse\n\t\tself:setupSpectator(player) -- Set the player to be a spectator.\n\tend\nend\n\n\nfunction Game:calculateOccupancy()\n\tlocal biggestNationSize = ReplicatedStorage.Data.BiggestNationSize.Value\n\tlocal mapLandSize = ReplicatedStorage.Data.MapLandSize.Value\n\n\tlocal occupancy = biggestNationSize / mapLandSize\n\n\treturn occupancy\nend\n\nlocal function getLandValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\tlocal getBotData = game.ReplicatedStorage.BotData:FindFirstChild(tostring(player))\n\t\tif getBotData then\n\t\t\treturn getBotData.Land.Value\n\t\telse\n\t\t\treturn\n\t\tend\n\telse\n\t\tif player and player:FindFirstChild(\"leaderstats\") then\n\t\t\treturn player.leaderstats.Land.Value\n\t\telse\n\t\t\treturn\n\t\tend\n\tend\n\nend\n\n\n\n\nlocal alivePlayerIds = {}\nlocal deadPlayerIds = {}\n\nlocal gameStart = false\nlocal gameOver = false\nlocal gameNotOver = false\nlocal teamNames = {\"Red\", \"Blue\", \"Green\", \"Yellow\", \"Pink\", \"Cyan\", \"Black\", \"White\"}\n-- handle player ticks\nfunction Game:tickMath(gameTick)\n\t\n\tlocal gamemode = ReplicatedStorage.Data.Gamemode.Value\n\t\n\tif gameStart == false then\n\t\tfor i,v in Nation.byPlayerId do\n\t\t\ttable.insert(alivePlayerIds, v.playerId)\n\t\tend\n\t\tgameStart = true\n\t\t--print(alivePlayerIds)\n\tend\n\t--local remainingNations = difference(alivePlayerIds, deadPlayerIds)\n\t--print(remainingNations)\n\t-- add troops to all Nations\n\t--print(gamemode)\n\tif gamemode == \"FFA\" and gameOver == false then\n\t\t--print(\"isFFA\")\n\t\t-- check to ensure all surviving nations are on the same ally!\n\t\tfor i, v in ipairs(alivePlayerIds) do\n\t\t\t--print(v)\n\t\t\tif i > 1 then\n\t\t\t\tif not table.find(Nation.byPlayerId[alivePlayerIds[1]].Allies, v) then\n\t\t\t\t\t--break\n\t\t\t\t\tgameNotOver = true\n\t\t\t\t\tbreak\n\t\t\t\telse --if gameNotOver == false then\n\t\t\t\t\tif i == #alivePlayerIds then\n\t\t\t\t\t\tgameOver = true\n\t\t\t\t\t\t\n\t\t\t\t\t\tprint(\"GAME OVER\")\n\t\t\t\t\t\tself.gameStatus = 3\n\t\t\t\t\t\tReplicatedStorage.Data.GameStatus.Value = 3\n\t\t\t\t\t\tReplicatedStorage.Remotes.WinEvent:FireAllClients(tostring(Nation.byPlayerId[alivePlayerIds[1]].Name))\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tgameNotOver = false\n\t\t\telseif #alivePlayerIds == 1 then\n\t\t\t\tgameOver = true\n\t\t\t\tprint(\"GAME OVER\")\n\t\t\t\tself.gameStatus = 3\n\t\t\t\tReplicatedStorage.Data.GameStatus.Value = 3\n\t\t\t\tReplicatedStorage.Remotes.WinEvent:FireAllClients(tostring(Nation.byPlayerId[alivePlayerIds[1]].Name))\n\t\t\tend\n\t\t\t\n\t\tend\n\telseif gameOver == false then -- TDM and zombot\n\t\t-- check to ensure all surviving nations are on the same team!\n\t\tfor i, v in ipairs(alivePlayerIds) do\n\t\t\tif i > 1 then\n\t\t\t\tif Nation.byPlayerId[alivePlayerIds[1]].Team ~= Nation.byPlayerId[alivePlayerIds[i]].Team then\n\t\t\t\t\t\n\t\t\t\t\tgameNotOver = true\n\t\t\t\t\tbreak\n\t\t\t\telse --if gameNotOver == false then\n\t\t\t\t\tif i == #alivePlayerIds then\n\t\t\t\t\t\tgameOver = true\n\t\t\t\t\t\tprint(\"GAME OVER\")\n\t\t\t\t\t\tself.gameStatus = 3\n\t\t\t\t\t\tReplicatedStorage.Data.GameStatus.Value = 3\n\t\t\t\t\t\tReplicatedStorage.Remotes.WinEvent:FireAllClients(teamNames[Nation.byPlayerId[alivePlayerIds[1]].Team])\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tgameNotOver = false\n\t\t\telseif #alivePlayerIds == 1 then\n\t\t\t\t-- is last\n\t\t\t\tgameOver = true\n\t\t\t\tprint(\"GAME OVER\")\n\t\t\t\tself.gameStatus = 3\n\t\t\t\tReplicatedStorage.Data.GameStatus.Value = 3\n\t\t\t\tReplicatedStorage.Remotes.WinEvent:FireAllClients(teamNames[Nation.byPlayerId[alivePlayerIds[1]].Team])\n\t\t\tend\n\n\t\tend\n\tend\n\t\n\tfor _, nation in pairs(Nation.byPlayerId) do\n\t\tlocal success, result = pcall(function()\n\n\t\t\tlocal nationId = nation.playerId\n\t\t\tlocal player = nation.playerId\n\n\t\t\tif nation.isBot == false then\n\t\t\t\tif game.Players:GetPlayerByUserId(player) then\n\t\t\t\t\tplayer = game.Players:GetPlayerByUserId(player)\n\t\t\t\telse\n\t\t\t\t--\treturn\n\t\t\t\t\t\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\t\n\n\t\t\tif getLandValue(player) == 0 and table.find(deadPlayerIds, nation.playerId) == nil then\n\t\t\t\t-- make sure it doesnt repeat this if its dead already\n\t\t\t\t-- table of dead playerIds\n\t\t\t\ttable.remove(alivePlayerIds, table.find(alivePlayerIds, nation.playerId))\n\t\t\t\ttable.insert(deadPlayerIds, nation.playerId)\n\t\t\t\t--print(deadPlayerIds)\n\t\t\t\n\t\t\t\t-- remove player tags\n\t\t\t\tfor i,player in ipairs (game.Players:GetChildren()) do\n\t\t\t\t\tReNotify(player, tostring(nation.Name .. \" has fell.\"),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType = \"critical\";\n\t\t\t\t\t\t\tTimeout = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\tend\n\n\n\t\t\t\tlocal tag = game.Workspace.Tags:FindFirstChild(nationId)\n\t\t\t\tif tag then\n\t\t\t\t\ttag:Destroy()\n\t\t\t\tend\n\n\n\t\t\t\t-- Check if the player with the given userId is in the game\n\t\t\t\tif typeof(player) == \"Instance\" then\n\t\t\t\t\t--local playerObj = game.Players:GetPlayerByUserId(player)\n\n\t\t\t\t\t-- Team the player to spectators (Assuming you have a Spectators team)\n\t\t\t\t\t--local spectatorsTeam = game.Teams:FindFirstChild(\"Spectators\")\n\t\t\t\t\tplayer.Team = game:GetService(\"Teams\")[\"Spectators\"]\n\n\n\t\t\t\t\t-- Kill the player (assuming you have a function to do that)\n\t\t\t\t\tlocal function killPlayer(player)\n\t\t\t\t\t\tplayer.Character.Humanoid.Health = 0\n\t\t\t\t\t\t-- You should implement logic to handle player death here.\n\t\t\t\t\t\t-- For example, respawning the player or ending their game.\n\t\t\t\t\t\t-- This could involve setting their Humanoid's health to 0, etc.\n\t\t\t\t\tend\n\n\t\t\t\t\t-- Make the player half transparent\n\n\n\t\t\t\t\t-- Call the functions to kill and make the player half transparent\n\t\t\t\t\tkillPlayer(player)\n\t\t\t\t\tlocal playerGui = player.PlayerGui\n\t\t\t\t\tplayerGui.ExitGame.Window.Visible = true\n\t\t\t\t\t\n\t\t\t\t\t--makePlayerHalfTransparent(player)\n\n\n\n\t\t\t\tend\n\n\t\t\tend\n\n\n\n\t\t\tif gameTick % 10 == 0 then\n\t\t\t\t-- big boost\n\t\t\t\tCalculate.updateBalanceFromIncome(player)\n\t\t\telse\n\t\t\t\t-- regular interest boost\n\t\t\t\tCalculate.updateBalanceFromInterest(player)\n\t\t\tend\n\n\t\t\tCalculate.updateInterestRate(player,gameTick)\n\t\tend)\n\t\t\n\t\tif success == false then\n\t\t\twarn(\"GAME TICK ITERATION FAILED:\", result)\n\t\tend\n\tend\nend\n\n\n-- handle bot ticks\n\n-- use calculations! mirror how actionHandler handles it\nfunction Game:botAI(botId)\n\t\n\tlocal botNation = Nation.byPlayerId[botId]\n\tif botNation == nil then\n\t\twarn(\"Bot nation couldn't be found with id:\", botId, Nation.byPlayerId)\n\tend\n\t\n\t\n\t-- implement evaluation of troops and enemies to determine attack\n\t-- needs quick math to end the thread and return if it doesnt meet density requirements or something\n\t-- add in donation logic if its surrounded by friendlies\n\t-- add boat logic if surrounded by friendlies but also has water\n\t-- raycast randomly and if it can find place to go, send boat\n\t\n\t-- random agressiveness to determine what size enemy willing to attack\n\t\n\t\n\tif Calculate.botAction(botId) then\n\t\t-- Check for empty land (playerId \"2\")\n\t\tif botNation:SharesBordersWith(2) then\n\t\t\t-- \n\t\t\tActions.Expand(botId)\n\n\t\telse\n\t\t\t-- Attack a random neighbor if no empty land\n\t\t\tlocal randomEnemy, callback, pixel, pixelIndex = botNation:GetRandomEnemy()\n\t\t\t--warn(\"enemy:\", randomEnemy, \"pixel:\", pixel, \"pixel index:\", pixelIndex)\n\t\t\t-- attack from random border\n\t\t\tif randomEnemy then\n\t\t\t\tActions.Attack(botId, callback or function() return randomEnemy end, botId, pixel, pixelIndex)  -- Assuming you have an \"Attack\" function in actionsTemp\n\t\t\t\t--task.wait()\n\t\t\tend\n\t\tend\n\tend\nend\n\n\n-- CROWN UI\n\n-- Function to find the player with the most land\nfunction Game:findNationWithMostLand()\n\tlocal maxLand = 0\n\tlocal nationWithMostLand = nil\n\n\tfor _, nation in pairs(Nation.byPlayerId) do\n\t\tif #nation.borderPixels > 0 then -- Ignore dead nations\n\t\t\tlocal landValue = 0\n\t\t\tif nation.isBot == true then\n\t\t\t\t-- It's a bot, get the land value from ReplicatedStorage.BotData\n\t\t\t\tlandValue = game.ReplicatedStorage.BotData[tostring(nation.playerId)].Land.Value\n\t\t\telse\n\t\t\t\t-- It's a player, get the land value from leaderstats\n\t\t\t\tlocal player = game.Players:GetPlayerByUserId(nation.playerId)\n\t\t\t\tif player and player.leaderstats then\n\t\t\t\t\tlandValue = player.leaderstats.Land.Value\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif landValue > maxLand then\n\t\t\t\tmaxLand = landValue\n\t\t\t\tnationWithMostLand = nation.playerId\n\t\t\tend\n\t\tend\n\tend\n\n\treturn nationWithMostLand\nend\n\n\nlocal RecentCrownTag = nil\n\nlocal botGate = true\nlocal gameTicks = 0\n-- Main game loop\nfunction Game:gameLoop()\n\t--Actions = require(script.Parent.ActionHandler.Actions)\n\t--task.spawn(function()\n\t--\twhile task.wait() do\n\t--\t\ttask.wait(self.tickLength)\n\t--\t\tfor playerId, _ in Nation.byPlayerId do\n\t--\t\t\tlocal player = game.Players:GetPlayerByUserId(playerId)\n\t--\t\t\twarn(playerId, \"nation land:\", Actions.getLandValue(player or playerId))\n\t--\t\tend\n\t--\tend\n\t--end)\n\t\n\twhile task.wait(self.tickLength) do\n\t\t--local success, result = pcall(function()\n\n\t\t\tif self.gameStatus == 0 then\n\t\t\t\t--print(\"loading...\")\n\t\t\telseif self.gameStatus == 1 then\n\t\t\t\t--print(\"can spawn now... \" .. self.ticksToSpawn)\n\t\t\t\tself.ticksToSpawn = self.ticksToSpawn - 1\n\t\t\t\tgame.ReplicatedStorage.Data.TicksToSpawn.Value = game.ReplicatedStorage.Data.TicksToSpawn.Value - 1\n\t\t\t\tif self.ticksToSpawn < 1 then\n\t\t\t\t\tReplicatedStorage:WaitForChild(\"Data\").GameStatus.Value = 2\n\t\t\t\t\tself.gameStatus = 2\n\t\t\t\t\tprint(\"successfully changed gamestatus\")\n\t\t\t\tend\n\t\t\t\tprint(self.ticksToSpawn)\n\t\t\telseif self.gameStatus == 2 then\n\t\t\t\t-- add tick count\n\t\t\t\tReplicatedStorage.Data.CurrentTick.Value = ReplicatedStorage.Data.CurrentTick.Value + 1 \n\n\t\t\t\tgameTicks += 1\n\n\t\t\t\t-- \"Main loop\" If 99% occupancy, shut it down\n\t\t\t\tif self:calculateOccupancy() >= 0.99 then\n\t\t\t\t\tReplicatedStorage:WaitForChild(\"Data\").GameStatus.Value = 3\n\t\t\t\t\tself.gameStatus = 3\n\t\t\t\tend\n\n\t\t\t\t-- add troops to all nations per tick\n\t\t\t\tself:tickMath(gameTicks)\n\n\t\t\t\t-- Calculate the player with the most land\n\t\t\t\tlocal nationWithMostLand = self:findNationWithMostLand()\n\n\t\t\t\tif nationWithMostLand then\n\t\t\t\t\tif RecentCrownTag ~= nil then\n\t\t\t\t\t\tRecentCrownTag.Visible = false\n\t\t\t\t\tend\n\t\t\t\t\tgame.Workspace.Tags[nationWithMostLand].Crown.Visible = true\n\t\t\t\t\tRecentCrownTag = game.Workspace.Tags[nationWithMostLand].Crown\n\t\t\t\t\t--print(\"Player with the most land: \" .. playerWithMostLand.Name)\n\t\t\t\telse\n\t\t\t\t\t--print(\"No player found with the most land.\")\n\t\t\t\tend\n\t\t\t\t--if gameTicks % 10 == 1 then\n\t\t\t\t-- run bot AI every tick to determine if it wants to expand/attack or not\n\n\t\t\t\tfor _, nation in pairs(Nation.byPlayerId) do\n\t\t\t\t\tif nation.isBot and #nation.borderPixels > 0 then\n\t\t\t\t\t\t-- need to check if bot exists\n\n\t\t\t\t\t\t-- run bot AI to check for actions from each bot every tick\t\n\t\t\t\t\t\tself:botAI(nation.playerId)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t--end\n\n\t\t\t\t-- Add more game logic as necessary here.\n\t\t\telseif self.gameStatus == 3 then\n\t\t\t\tprint(\"round ended\")\n\t\t\t\t-- Handle end-of-round logic, such as cleanup or setting up the next round.\n\t\t\tend\n\t\t--end)\n\t\t\n\t\t--if success == false then\n\t\t--\twarn(\"GAME LOOP ITERATION FAILED:\", result)\n\t\t--end\n\tend\n\t\n\nend\n\n-- Setup player added event\nfunction Game:setupEvents()\n\t\n\tPlayers.PlayerAdded:Connect(function(player)\n\t\tplayer:LoadCharacter()\n\t\tself:playerAdded(player)\n\tend)\nend\n\n-- Run the game\nlocal gameInstance = Game.new()\ngameInstance:gameLoop()\n\n\n-- set up map and mode from first player's teleportdata\n-- set up pixel data (parent the MapData to serverscriptservice)\n\n\n\n-- changes GameStatus as it loads, so gameServer can double check client inputs, and it limits clients from sending remotes when not allowed + informs client of game state\n\n-- declare nations as people join\n-- “Main loop” If 99% occupancy, shut it down\n-- ASYNC Each tick after round starts, run addTroops\n"}]