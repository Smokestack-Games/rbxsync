[{"className":"Script","name":"ActionHandler","properties":{"Capabilities":{"type":"Enum","value":{"enumType":"SecurityCapabilities","value":""}},"Disabled":{"type":"bool","value":false},"LinkedSource":{"type":"Enum","value":{"enumType":"ContentId","value":""}},"RunContext":{"type":"Enum","value":{"enumType":"RunContext","value":"Legacy"}},"Source":{"type":"ProtectedString","value":"-- This script should handle all client inputs, while Main handles the loop and informs this script of the game state (spawning, active, ended)\n\n-- THIS SCRIPT IS THE ONLY ONE EDITING MAPDATA!! Main will parent it to serverscriptservice, and the Action module will require it. It requires when the GameStatus changes.\n\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal ButtonEvent = ReplicatedStorage.Remotes.ButtonEvent\nlocal TerritorySelectEvent = ReplicatedStorage.Remotes.TerritorySelectEvent\nlocal GetPixelTypeFunction = ReplicatedStorage.Remotes.GetPixelTypeFunction\n\nlocal mapDataModule = nil\nlocal mapData = nil\n\ngame.ReplicatedStorage.ChildAdded:Connect(function(child)\n\tif child.Name == \"MapData\" then\n\t\tmapDataModule = child\n\t\tmapData = require(mapDataModule)\n\tend\nend)\n\n\nlocal actionModule = script:WaitForChild(\"Actions\")\nlocal Actions = require(actionModule)\n\n\nlocal width = mapData.width --or 250\nlocal height = mapData.height --or 250\n\n\nfunction getIndexFromPosition(x, y)\n\treturn x * 250 + y + 1\nend\n\n\nfunction getPixelIndexFromMouseHit(position)\n\tlocal roundedX = math.floor(position.x + 0.5)\n\tlocal roundedY = math.floor(position.z + 0.5)\n\n\tif roundedX < 0 or roundedX > width or roundedY < 0 or roundedY > height then\n\t\treturn 0 -- Out of map bounds\n\tend\n\n\t-- Calculate pixel ID using the helper function\n\tlocal pixelID = getIndexFromPosition(roundedX, roundedY)\n\treturn pixelID\nend\n\nfunction getPixelFromMouseHit(position)\n\t-- Round the position to nearest whole number\n\tlocal roundedX = math.floor(position.x + 0.5)\n\tlocal roundedY = math.floor(position.z + 0.5)\n\n\tif roundedX < 0 or roundedX > width or roundedY < 0 or roundedY > height then\n\t\treturn 0 -- Out of map bounds\n\tend\n\n\t-- Calculate pixel ID using the helper function\n\tlocal pixelID = getIndexFromPosition(roundedX, roundedY)\n\n\t-- Return the pixel type from pixelData using pixelID\n\treturn mapData.pixelData[pixelID] or 0 -- Return 0 if the pixelID doesn't exist for some reason\n\nend\n\n\n-- This returns pixelType so the client can display appropriate action buttons\nGetPixelTypeFunction.OnServerInvoke = function(player, position)\n\treturn getPixelFromMouseHit(position)\nend\n\n\n\t\n\t\nTerritorySelectEvent.OnServerInvoke = function(client, player, pixelType, position)\n\tlocal pixel = getPixelIndexFromMouseHit(position)\n\treturn Actions.CheckTerritoryButtons(player, pixelType, pixel)\nend\n\n\n\n\n-- HANDLES TROOPS, NOT LAND\n-- after an action runs, the player's Land will be updated\n\n-- runs calculations for actions\n-- runs actions based on the calculation results\n-- send remotes to clients to alert of incoming attacks, ally requests, ally severances, and donations\n-- set the troop values after each expansion and update the client UI (sent troops feed and nationTags) with the new troop count, the leaderstats will automatically update\n-- remember sent troops is separate from your troop count, and they get readded if they arent all killed off\n\nlocal Calculate = require(script.Calculate)\n\n-- This script executes button actions assuming they are valid (and limit actions per tick)\nButtonEvent.OnServerEvent:Connect(function(player, buttonName, position)\n\tif buttonName == \"Spawn\" then\n\t\t-- Handle Spawn button logic\n\t\t-- should verify if its valid spawn\n\t\t\n\t\tprint(\"Spawn action by\", player.Name)\n\t\t\n\t\tif getPixelFromMouseHit(position) == 2 and ReplicatedStorage.Data.GameStatus.Value == 1 then\n\t\t\tActions.Spawn(player.UserId, getPixelIndexFromMouseHit(position))\n\t\tend\n\t\t\n\telseif buttonName == \"Expand\" then\n\t\t-- Handle Expand button logic\n\t\t\n\t\tprint(\"Expand action by\", player.Name)\n\t\tif getPixelFromMouseHit(position) == 2 then\n\t\t\t\n\t\t\t-- THIS IS FIRED BY PLAYER, BOTTICK WILL USE DIFFERENT CALCULATIONS\n\t\t\t-- calculate\n\t\n\t\t\t-- Calculations for expanding ran inside Actions module\n\t\t\t-- Actions module will send remotes to expanding client to show troops as it expands each expansion\n\t\t\t\n\t\t\tActions.Expand(player.UserId)\n\t\t\t\n\t\t\t-- Update clients with the new troop count and territory\n\t\t\t-- Send any necessary remote events to clients\n\n\t\tend\n\t\t\n\t\t\n\t-- THE BELOW NEED VERIFICATION AS WELL\t\n\telseif buttonName == \"Attack\" then\n\t\t-- Handle Attack button logic\n\t\t\n\t\tprint(\"Attack action by\", player.Name)\n\t\t\n\t\t\n\t\t\t-- THIS IS FIRED BY PLAYER, BOTTICK WILL USE DIFFERENT CALCULATIONS\n\t\t\t-- calculate\n\n\t\t\t-- then expand 1\n\t\t\tActions.Attack(player.UserId, getPixelFromMouseHit, position)\n\n\t\t\t-- update clients\n\n\t\t\t-- if remaining troops from calculate, attack until ended\n\telseif buttonName == \"Boat\" then\n\t\t-- Handle Ally button logic\n\n\t\tprint(\"Boat action by\", player.Name)\n\t\ttask.spawn(function()\n\t\t\tlocal pixel, pixelIndex = getPixelFromMouseHit(position), getPixelIndexFromMouseHit(position)\n\t\t\tlocal useCallback\n\t\t\tif pixel == 2 then\n\t\t\t\tuseCallback = Actions.Expand\n\t\t\telse\n\t\t\t\tuseCallback = Actions.Attack\n\t\t\tend\n\t\t\t\n\t\t\tuseCallback(player.UserId, Actions.Boat, player.UserId, pixel, pixelIndex)\n\t\tend)\n\n\n\telseif buttonName == \"Ally\" then\n\t\t-- Handle Ally button logic\n\t\t\n\t\tprint(\"Ally action by\", player.Name)\n\t\t\n\t\tActions.Ally(player.UserId, getPixelFromMouseHit(position))\n\telseif buttonName == \"Donate\" then\n\t\t-- Handle Donate button logic\n\t\t\n\t\tprint(\"Donate action by\", player.Name)\n\t\tActions.Donate(player.UserId, getPixelFromMouseHit(position))\n\tend\nend)\n"}},"referenceId":"00000045-4cdd-8739-fae0-000002dc1ce0","source":"-- This script should handle all client inputs, while Main handles the loop and informs this script of the game state (spawning, active, ended)\n\n-- THIS SCRIPT IS THE ONLY ONE EDITING MAPDATA!! Main will parent it to serverscriptservice, and the Action module will require it. It requires when the GameStatus changes.\n\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal ButtonEvent = ReplicatedStorage.Remotes.ButtonEvent\nlocal TerritorySelectEvent = ReplicatedStorage.Remotes.TerritorySelectEvent\nlocal GetPixelTypeFunction = ReplicatedStorage.Remotes.GetPixelTypeFunction\n\nlocal mapDataModule = nil\nlocal mapData = nil\n\ngame.ReplicatedStorage.ChildAdded:Connect(function(child)\n\tif child.Name == \"MapData\" then\n\t\tmapDataModule = child\n\t\tmapData = require(mapDataModule)\n\tend\nend)\n\n\nlocal actionModule = script:WaitForChild(\"Actions\")\nlocal Actions = require(actionModule)\n\n\nlocal width = mapData.width --or 250\nlocal height = mapData.height --or 250\n\n\nfunction getIndexFromPosition(x, y)\n\treturn x * 250 + y + 1\nend\n\n\nfunction getPixelIndexFromMouseHit(position)\n\tlocal roundedX = math.floor(position.x + 0.5)\n\tlocal roundedY = math.floor(position.z + 0.5)\n\n\tif roundedX < 0 or roundedX > width or roundedY < 0 or roundedY > height then\n\t\treturn 0 -- Out of map bounds\n\tend\n\n\t-- Calculate pixel ID using the helper function\n\tlocal pixelID = getIndexFromPosition(roundedX, roundedY)\n\treturn pixelID\nend\n\nfunction getPixelFromMouseHit(position)\n\t-- Round the position to nearest whole number\n\tlocal roundedX = math.floor(position.x + 0.5)\n\tlocal roundedY = math.floor(position.z + 0.5)\n\n\tif roundedX < 0 or roundedX > width or roundedY < 0 or roundedY > height then\n\t\treturn 0 -- Out of map bounds\n\tend\n\n\t-- Calculate pixel ID using the helper function\n\tlocal pixelID = getIndexFromPosition(roundedX, roundedY)\n\n\t-- Return the pixel type from pixelData using pixelID\n\treturn mapData.pixelData[pixelID] or 0 -- Return 0 if the pixelID doesn't exist for some reason\n\nend\n\n\n-- This returns pixelType so the client can display appropriate action buttons\nGetPixelTypeFunction.OnServerInvoke = function(player, position)\n\treturn getPixelFromMouseHit(position)\nend\n\n\n\t\n\t\nTerritorySelectEvent.OnServerInvoke = function(client, player, pixelType, position)\n\tlocal pixel = getPixelIndexFromMouseHit(position)\n\treturn Actions.CheckTerritoryButtons(player, pixelType, pixel)\nend\n\n\n\n\n-- HANDLES TROOPS, NOT LAND\n-- after an action runs, the player's Land will be updated\n\n-- runs calculations for actions\n-- runs actions based on the calculation results\n-- send remotes to clients to alert of incoming attacks, ally requests, ally severances, and donations\n-- set the troop values after each expansion and update the client UI (sent troops feed and nationTags) with the new troop count, the leaderstats will automatically update\n-- remember sent troops is separate from your troop count, and they get readded if they arent all killed off\n\nlocal Calculate = require(script.Calculate)\n\n-- This script executes button actions assuming they are valid (and limit actions per tick)\nButtonEvent.OnServerEvent:Connect(function(player, buttonName, position)\n\tif buttonName == \"Spawn\" then\n\t\t-- Handle Spawn button logic\n\t\t-- should verify if its valid spawn\n\t\t\n\t\tprint(\"Spawn action by\", player.Name)\n\t\t\n\t\tif getPixelFromMouseHit(position) == 2 and ReplicatedStorage.Data.GameStatus.Value == 1 then\n\t\t\tActions.Spawn(player.UserId, getPixelIndexFromMouseHit(position))\n\t\tend\n\t\t\n\telseif buttonName == \"Expand\" then\n\t\t-- Handle Expand button logic\n\t\t\n\t\tprint(\"Expand action by\", player.Name)\n\t\tif getPixelFromMouseHit(position) == 2 then\n\t\t\t\n\t\t\t-- THIS IS FIRED BY PLAYER, BOTTICK WILL USE DIFFERENT CALCULATIONS\n\t\t\t-- calculate\n\t\n\t\t\t-- Calculations for expanding ran inside Actions module\n\t\t\t-- Actions module will send remotes to expanding client to show troops as it expands each expansion\n\t\t\t\n\t\t\tActions.Expand(player.UserId)\n\t\t\t\n\t\t\t-- Update clients with the new troop count and territory\n\t\t\t-- Send any necessary remote events to clients\n\n\t\tend\n\t\t\n\t\t\n\t-- THE BELOW NEED VERIFICATION AS WELL\t\n\telseif buttonName == \"Attack\" then\n\t\t-- Handle Attack button logic\n\t\t\n\t\tprint(\"Attack action by\", player.Name)\n\t\t\n\t\t\n\t\t\t-- THIS IS FIRED BY PLAYER, BOTTICK WILL USE DIFFERENT CALCULATIONS\n\t\t\t-- calculate\n\n\t\t\t-- then expand 1\n\t\t\tActions.Attack(player.UserId, getPixelFromMouseHit, position)\n\n\t\t\t-- update clients\n\n\t\t\t-- if remaining troops from calculate, attack until ended\n\telseif buttonName == \"Boat\" then\n\t\t-- Handle Ally button logic\n\n\t\tprint(\"Boat action by\", player.Name)\n\t\ttask.spawn(function()\n\t\t\tlocal pixel, pixelIndex = getPixelFromMouseHit(position), getPixelIndexFromMouseHit(position)\n\t\t\tlocal useCallback\n\t\t\tif pixel == 2 then\n\t\t\t\tuseCallback = Actions.Expand\n\t\t\telse\n\t\t\t\tuseCallback = Actions.Attack\n\t\t\tend\n\t\t\t\n\t\t\tuseCallback(player.UserId, Actions.Boat, player.UserId, pixel, pixelIndex)\n\t\tend)\n\n\n\telseif buttonName == \"Ally\" then\n\t\t-- Handle Ally button logic\n\t\t\n\t\tprint(\"Ally action by\", player.Name)\n\t\t\n\t\tActions.Ally(player.UserId, getPixelFromMouseHit(position))\n\telseif buttonName == \"Donate\" then\n\t\t-- Handle Donate button logic\n\t\t\n\t\tprint(\"Donate action by\", player.Name)\n\t\tActions.Donate(player.UserId, getPixelFromMouseHit(position))\n\tend\nend)\n"}]