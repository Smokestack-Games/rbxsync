[{"className":"ModuleScript","name":"Calculate","properties":{"Capabilities":{"type":"Enum","value":{"enumType":"SecurityCapabilities","value":""}},"LinkedSource":{"type":"Enum","value":{"enumType":"ContentId","value":""}},"Source":{"type":"ProtectedString","value":"-- Calculate Module\nlocal Calculate = {}\n\n\n-- adjust for small size (1/12th)\nlocal SMALL_MAP_FACTOR = 1\n\nlocal CONQUER_COST_PER_PIXEL = 2 --* SMALL_MAP_FACTOR -- Cost in balance to conquer 1 pixel\n\n-- Constants for game rules\nlocal INITIAL_INTEREST = 0.07  -- Initial interest rate\n\n-- remember, actual limit is 0, .01 to 0 is from soft to hard limits\nlocal MIN_INTEREST = 0.01      -- Minimum interest rate\nlocal MAX_INTEREST = 0.026     -- Maximum territorial interest\nlocal INITIAL_TIME = 107-- * 2   -- Initial time in ticks for higher interest rate\nlocal SOFT_LIMIT_MULTIPLIER = 100 -- 100 troops/tile is when it starts to decrease\nlocal HARD_LIMIT_MULTIPLIER = 150 -- hard limit of the density\n\n\n-- get Troops\nlocal function getTroopValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\t\n\t\treturn game.ReplicatedStorage.BotData[tostring(player)].Troops.Value\n\telse\n\t\treturn player.leaderstats.Troops.Value\n\tend\nend\n\n-- update Troops\nlocal function updateTroopValue(player, newValue)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\tlocal oldTroops = game.ReplicatedStorage.BotData[tostring(player)].Troops\n\t\toldTroops.Value = math.max(0, newValue)\n\telse\n\t\tlocal oldTroops = player.leaderstats.Troops\n\t\toldTroops.Value = math.max(0, newValue)\n\tend\t\nend\n\n-- get interest\nlocal function getInterestValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\treturn game.ReplicatedStorage.BotData[tostring(player)].Interest.Value / 100\n\telse\n\t\treturn player.leaderstats.Interest.Value / 100\n\tend\nend\n\n-- update interest\nlocal function updateInterestValue(player, newValue)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\t\n\t\n\tif isBot then\n\t\tlocal oldInterest = game.ReplicatedStorage.BotData[tostring(player)].Interest\n\t\toldInterest.Value = newValue * 100\n\telse\n\t\t--print(newValue)\n\t\tlocal oldInterest = player.leaderstats.Interest\n\t\t--print(oldInterest.Value)\n\t\toldInterest.Value = newValue * 100\n\tend\t\nend\n\n-- get land\nlocal function getLandValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\t\n\t\treturn game.ReplicatedStorage.BotData[tostring(player)].Land.Value\n\telse\n\t\treturn player.leaderstats.Land.Value\n\tend\nend\n\n-- update land\nlocal function updateLandValue(playerNation, landChange)\n\tlocal userId = playerNation.playerId\n\tlocal player = playerNation.isBot and game.ReplicatedStorage.BotData[tostring(userId)] or game.Players:GetPlayerByUserId(userId)\n\tlocal landStat = playerNation.isBot and player.Land or player.leaderstats.Land\n\n\t-- Adjust the land value safely, ensuring it never goes below zero\n\tlandStat.Value = math.max(0, landStat.Value + landChange)\nend\n\n\n\n\n\n-- Utility functions for interest and limits\nlocal function calculateTerritorialInterest(land)\n\t-- Ensure territorial interest is between MIN_INTEREST and MAX_INTEREST\n\tlocal territorialInterest = MIN_INTEREST + (1.6 * math.sqrt(land)) / 100\n\treturn math.min(territorialInterest, MAX_INTEREST)\nend\n\nlocal function calculateInitialAugmentationFactor(gameTicks)\n\t-- Ensure the initial augmentation factor decreases from INITIAL_INTEREST to 1 over INITIAL_TIME\n\tif gameTicks <= INITIAL_TIME then\n\t\tlocal decayFactor = (gameTicks / INITIAL_TIME)\n\t\t--print(INITIAL_INTEREST * (1 - decayFactor))\n\t\treturn math.max(MIN_INTEREST, INITIAL_INTEREST * (1 - decayFactor))\n\t\t\n\telse\n\t\treturn 1 -- After INITIAL_TIME, the factor is 1 (no augmentation)\n\tend\nend\n\nlocal function calculateBalanceLimitingFactor(density, softLimit, hardLimit)\n\t-- Ensure the balance limiting factor is between 0 and 1\n\tif density < softLimit then\n\t\treturn 1\n\telseif density < hardLimit then\n\t\treturn (hardLimit - density) / (hardLimit - softLimit)\n\telse\n\t\treturn 0\n\tend\nend\n\n-- Function to calculate the current interest rate based on game ticks, troops, and land\nlocal function calculateInterestRate(troops, land, gameTicks)\n\tlocal softLimit =  SOFT_LIMIT_MULTIPLIER\n\tlocal hardLimit =  HARD_LIMIT_MULTIPLIER\n\tlocal density = troops / land\n\n\t-- below comment is old code? seems like this is the part that doesnt work as intended\n\t--local territorialInterest = calculateTerritorialInterest(land)\n\t\n\t\n\tlocal initialAugmentationFactor = calculateInitialAugmentationFactor(gameTicks)\n\tlocal balanceLimitingFactor = calculateBalanceLimitingFactor(density, softLimit, hardLimit)\n\t\n\tlocal finalInterestRate\n\t\n\tif initialAugmentationFactor < 1 then\n\t\tfinalInterestRate = initialAugmentationFactor\n\telseif balanceLimitingFactor == 1 then\n\t\t-- if below softlimit, between 2.6 (density) and 1 (softlimit)\n\t\t-- use inverse density\n\t\t-- we use 100 because 100 is the soft limit\n\t\tlocal inverseDensity = SOFT_LIMIT_MULTIPLIER - density\n\t\tfinalInterestRate = ((1.6 * (inverseDensity/SOFT_LIMIT_MULTIPLIER)) + 1)  / 100\n\t\t\n\t--\tfinalInterestRate = MAX_INTEREST * balanceLimitingFactor\n\t\t\n\telseif balanceLimitingFactor > 0 then\n\t\t-- if between soft and hard, 1 to 0\n\t\t\n\t\t-- divide by 10 bc you want 1%, not 10%\n\t\treturn balanceLimitingFactor /10\n\telse\n\t\t-- should be 0 for 0 interest, ie max density\n\t\treturn balanceLimitingFactor /10\n\t\t\n\tend\n\t\n\t--finalInterestRate = math.max(finalInterestRate, MIN_INTEREST)\n\n\t--if density > hardLimit then\n\t--\tfinalInterestRate = 0\n\t--end\n\t--print (finalInterestRate)\n\treturn finalInterestRate\nend\n\n-- Function to update interest rate for a player\nfunction Calculate.updateInterestRate(player, gameTicks)\n\tlocal troops = getTroopValue(player)\n\tlocal land = getLandValue(player)\n\tlocal newInterestRate = calculateInterestRate(troops, land, gameTicks)\n\tlocal increment = 0.001\n\tnewInterestRate = math.round(newInterestRate / increment) * increment\n\t--if newInterestRate == 0 then\n\t\t\n\t--\tprint(newInterestRate)\n\t--\tprint(troops)\n\t--\tprint(land)\n\t--end\n\n\tupdateInterestValue(player, newInterestRate)\nend\n\n-- Function to update player balance due to interest growth\nfunction Calculate.updateBalanceFromInterest(player)\n\tlocal interestRate = getInterestValue(player) -- Interest should already be stored as a decimal\n\tlocal troops = getTroopValue(player)\n\tlocal land = getLandValue(player)\n\t\n\tlocal density = troops/land\n\n\tif density >= HARD_LIMIT_MULTIPLIER then\n\t\tlocal newTroops = land * HARD_LIMIT_MULTIPLIER\n\t\tupdateTroopValue(player, newTroops)\n\t\treturn\n\tend\n\t\n\tlocal newTroops = troops * (1 + interestRate)\n\t\n\tupdateTroopValue(player, newTroops)\nend\n\n\n\n\n\n\n-- Function to update player balance due to income growth\nfunction Calculate.updateBalanceFromIncome(player)\n\t\n\tlocal troops = getTroopValue(player)\n\tlocal land = getLandValue(player)\n\t\n\tlocal density = troops/land\n\t\n\tif density >= HARD_LIMIT_MULTIPLIER then\n\t\tlocal newTroops = land * HARD_LIMIT_MULTIPLIER\n\t\tupdateTroopValue(player, newTroops)\n\t\treturn\n\tend\n\t\n\tlocal newTroops = troops + (land * 2) --* 12\n\n\tupdateTroopValue(player, newTroops)\nend\n\n-- Combat mechanics and territory management functions\n\n-- Function to calculate expansion cost\nfunction Calculate.calculateExpansionCost(pixelsToConquer)\n\treturn pixelsToConquer * CONQUER_COST_PER_PIXEL\nend\n\n\n-- Function to conquer new pixels\n-- this gets called inside Actions, not ActionHandler\n-- Function to conquer new pixels\nfunction Calculate.expandTerritory(player, pixelsToConquer, attackingTroops)\n\tlocal costToExpand = Calculate.calculateExpansionCost(pixelsToConquer)\n\tif attackingTroops >= costToExpand then\n\t\t-- send update to client\n\t\t--updateTroopValue(player, -costToExpand)\n\t\t\n\t\treturn true, attackingTroops - costToExpand -- Expansion successful, return remaining troops\n\telse\n\t\tlocal newAttackerTroops = getTroopValue(player)  + attackingTroops\n\t\t-- add remainder troops\n\t\tupdateTroopValue(player, newAttackerTroops)\n\n\t\treturn false, attackingTroops -- Not enough balance to expand, return remaining troops\n\tend\nend\n\n\n\n-- Function to calculate defending troop density per border pixel\nfunction Calculate.calculateBorderDensity(defenderTroops, defenderLand)\n\t--  it takes 2 to take out 1\n\tlocal density = (defenderTroops / defenderLand) * 2\n\treturn density\nend\n\n\n\n\nfunction Calculate.botAction(botId)\n\tlocal botTroops =  getTroopValue(botId)\n\tlocal botLand = getLandValue(botId)\n\t\n\tlocal density = (botTroops / botLand)\n\tif density < math.random(8,32) or botLand < 1 then\n\t\treturn false\n\tend\n\treturn true\nend\n\n\n\n\n-- Function to calculate attack losses considering border pixels and troop density\nfunction Calculate.calculateAttackLosses(playerDefender, attackingTroops, borderAmount)\n\t-- Calculate the defending troop density\n\tlocal playerTroops = getTroopValue(playerDefender)\n\tlocal defendingDensity = Calculate.calculateBorderDensity(playerTroops, getLandValue(playerDefender))\n\n\t-- Calculate the number of troops the attacker loses based on the density (assuming a 1:1 ratio)\n\t--local attackerLosses = 0\n\t--for i = 1, borderPixels do\n\t--\tif attackingTroops <= 0 then break end\n\n\tlocal attackerLosses = borderAmount * defendingDensity\n\t\n\tattackingTroops = attackingTroops - attackerLosses\n\t\n\tif attackingTroops < 0 then\n\t\treturn 0, 0\n\tend\n\t--end\n\t\n\t\n\t-- Calculate the number of troops the defender loses (1:0.5 ratio)\n\tlocal defenderLosses = math.floor(math.min(attackerLosses/2, playerTroops))\n\t\n\tif attackerLosses > playerTroops then\n\t\tlocal newAttackerLosses = math.min(attackerLosses,playerTroops)\n\n\t\t-- this is the leftover troops if you end up wiping out the enemy, these get added back!\n\t\tlocal regainedTroops = attackerLosses - newAttackerLosses\n\t\t\n\t\tlocal newTroops = getTroopValue(playerDefender)  + regainedTroops\n\t\tupdateTroopValue(playerDefender, newTroops)\n\t\treturn newAttackerLosses, defenderLosses\n\tend\n\t\n\t\n\treturn attackerLosses, defenderLosses\nend\n\n-- Function to perform an attack\nfunction Calculate.attack(playerAttacker, playerDefender, attackingTroops, borderAmount)\n\t-- ... existing logic\n\tlocal attackerLosses, defenderLosses = Calculate.calculateAttackLosses(playerDefender, attackingTroops, borderAmount)\n\n\t-- Update balances after the attack\n\tlocal newAttackerTroops = getTroopValue(playerAttacker)  - attackingTroops\n\tlocal newDefenderTroops = getTroopValue(playerDefender)  - defenderLosses\n\t\n\t-- update enemy\n\tupdateTroopValue(playerDefender, newDefenderTroops)\n\n\t-- Return the results of the attack and the remaining attacking troops vvv\n\treturn attackerLosses, defenderLosses, attackingTroops - attackerLosses\nend\n\n\nreturn Calculate"}},"referenceId":"00000047-c942-cc5f-1ef0-0000753079ac","source":"-- Calculate Module\nlocal Calculate = {}\n\n\n-- adjust for small size (1/12th)\nlocal SMALL_MAP_FACTOR = 1\n\nlocal CONQUER_COST_PER_PIXEL = 2 --* SMALL_MAP_FACTOR -- Cost in balance to conquer 1 pixel\n\n-- Constants for game rules\nlocal INITIAL_INTEREST = 0.07  -- Initial interest rate\n\n-- remember, actual limit is 0, .01 to 0 is from soft to hard limits\nlocal MIN_INTEREST = 0.01      -- Minimum interest rate\nlocal MAX_INTEREST = 0.026     -- Maximum territorial interest\nlocal INITIAL_TIME = 107-- * 2   -- Initial time in ticks for higher interest rate\nlocal SOFT_LIMIT_MULTIPLIER = 100 -- 100 troops/tile is when it starts to decrease\nlocal HARD_LIMIT_MULTIPLIER = 150 -- hard limit of the density\n\n\n-- get Troops\nlocal function getTroopValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\t\n\t\treturn game.ReplicatedStorage.BotData[tostring(player)].Troops.Value\n\telse\n\t\treturn player.leaderstats.Troops.Value\n\tend\nend\n\n-- update Troops\nlocal function updateTroopValue(player, newValue)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\tlocal oldTroops = game.ReplicatedStorage.BotData[tostring(player)].Troops\n\t\toldTroops.Value = math.max(0, newValue)\n\telse\n\t\tlocal oldTroops = player.leaderstats.Troops\n\t\toldTroops.Value = math.max(0, newValue)\n\tend\t\nend\n\n-- get interest\nlocal function getInterestValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\treturn game.ReplicatedStorage.BotData[tostring(player)].Interest.Value / 100\n\telse\n\t\treturn player.leaderstats.Interest.Value / 100\n\tend\nend\n\n-- update interest\nlocal function updateInterestValue(player, newValue)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\t\n\t\n\tif isBot then\n\t\tlocal oldInterest = game.ReplicatedStorage.BotData[tostring(player)].Interest\n\t\toldInterest.Value = newValue * 100\n\telse\n\t\t--print(newValue)\n\t\tlocal oldInterest = player.leaderstats.Interest\n\t\t--print(oldInterest.Value)\n\t\toldInterest.Value = newValue * 100\n\tend\t\nend\n\n-- get land\nlocal function getLandValue(player)\n\tlocal isBot = typeof(player) ~= \"Instance\"\n\n\tif isBot then\n\t\t\n\t\treturn game.ReplicatedStorage.BotData[tostring(player)].Land.Value\n\telse\n\t\treturn player.leaderstats.Land.Value\n\tend\nend\n\n-- update land\nlocal function updateLandValue(playerNation, landChange)\n\tlocal userId = playerNation.playerId\n\tlocal player = playerNation.isBot and game.ReplicatedStorage.BotData[tostring(userId)] or game.Players:GetPlayerByUserId(userId)\n\tlocal landStat = playerNation.isBot and player.Land or player.leaderstats.Land\n\n\t-- Adjust the land value safely, ensuring it never goes below zero\n\tlandStat.Value = math.max(0, landStat.Value + landChange)\nend\n\n\n\n\n\n-- Utility functions for interest and limits\nlocal function calculateTerritorialInterest(land)\n\t-- Ensure territorial interest is between MIN_INTEREST and MAX_INTEREST\n\tlocal territorialInterest = MIN_INTEREST + (1.6 * math.sqrt(land)) / 100\n\treturn math.min(territorialInterest, MAX_INTEREST)\nend\n\nlocal function calculateInitialAugmentationFactor(gameTicks)\n\t-- Ensure the initial augmentation factor decreases from INITIAL_INTEREST to 1 over INITIAL_TIME\n\tif gameTicks <= INITIAL_TIME then\n\t\tlocal decayFactor = (gameTicks / INITIAL_TIME)\n\t\t--print(INITIAL_INTEREST * (1 - decayFactor))\n\t\treturn math.max(MIN_INTEREST, INITIAL_INTEREST * (1 - decayFactor))\n\t\t\n\telse\n\t\treturn 1 -- After INITIAL_TIME, the factor is 1 (no augmentation)\n\tend\nend\n\nlocal function calculateBalanceLimitingFactor(density, softLimit, hardLimit)\n\t-- Ensure the balance limiting factor is between 0 and 1\n\tif density < softLimit then\n\t\treturn 1\n\telseif density < hardLimit then\n\t\treturn (hardLimit - density) / (hardLimit - softLimit)\n\telse\n\t\treturn 0\n\tend\nend\n\n-- Function to calculate the current interest rate based on game ticks, troops, and land\nlocal function calculateInterestRate(troops, land, gameTicks)\n\tlocal softLimit =  SOFT_LIMIT_MULTIPLIER\n\tlocal hardLimit =  HARD_LIMIT_MULTIPLIER\n\tlocal density = troops / land\n\n\t-- below comment is old code? seems like this is the part that doesnt work as intended\n\t--local territorialInterest = calculateTerritorialInterest(land)\n\t\n\t\n\tlocal initialAugmentationFactor = calculateInitialAugmentationFactor(gameTicks)\n\tlocal balanceLimitingFactor = calculateBalanceLimitingFactor(density, softLimit, hardLimit)\n\t\n\tlocal finalInterestRate\n\t\n\tif initialAugmentationFactor < 1 then\n\t\tfinalInterestRate = initialAugmentationFactor\n\telseif balanceLimitingFactor == 1 then\n\t\t-- if below softlimit, between 2.6 (density) and 1 (softlimit)\n\t\t-- use inverse density\n\t\t-- we use 100 because 100 is the soft limit\n\t\tlocal inverseDensity = SOFT_LIMIT_MULTIPLIER - density\n\t\tfinalInterestRate = ((1.6 * (inverseDensity/SOFT_LIMIT_MULTIPLIER)) + 1)  / 100\n\t\t\n\t--\tfinalInterestRate = MAX_INTEREST * balanceLimitingFactor\n\t\t\n\telseif balanceLimitingFactor > 0 then\n\t\t-- if between soft and hard, 1 to 0\n\t\t\n\t\t-- divide by 10 bc you want 1%, not 10%\n\t\treturn balanceLimitingFactor /10\n\telse\n\t\t-- should be 0 for 0 interest, ie max density\n\t\treturn balanceLimitingFactor /10\n\t\t\n\tend\n\t\n\t--finalInterestRate = math.max(finalInterestRate, MIN_INTEREST)\n\n\t--if density > hardLimit then\n\t--\tfinalInterestRate = 0\n\t--end\n\t--print (finalInterestRate)\n\treturn finalInterestRate\nend\n\n-- Function to update interest rate for a player\nfunction Calculate.updateInterestRate(player, gameTicks)\n\tlocal troops = getTroopValue(player)\n\tlocal land = getLandValue(player)\n\tlocal newInterestRate = calculateInterestRate(troops, land, gameTicks)\n\tlocal increment = 0.001\n\tnewInterestRate = math.round(newInterestRate / increment) * increment\n\t--if newInterestRate == 0 then\n\t\t\n\t--\tprint(newInterestRate)\n\t--\tprint(troops)\n\t--\tprint(land)\n\t--end\n\n\tupdateInterestValue(player, newInterestRate)\nend\n\n-- Function to update player balance due to interest growth\nfunction Calculate.updateBalanceFromInterest(player)\n\tlocal interestRate = getInterestValue(player) -- Interest should already be stored as a decimal\n\tlocal troops = getTroopValue(player)\n\tlocal land = getLandValue(player)\n\t\n\tlocal density = troops/land\n\n\tif density >= HARD_LIMIT_MULTIPLIER then\n\t\tlocal newTroops = land * HARD_LIMIT_MULTIPLIER\n\t\tupdateTroopValue(player, newTroops)\n\t\treturn\n\tend\n\t\n\tlocal newTroops = troops * (1 + interestRate)\n\t\n\tupdateTroopValue(player, newTroops)\nend\n\n\n\n\n\n\n-- Function to update player balance due to income growth\nfunction Calculate.updateBalanceFromIncome(player)\n\t\n\tlocal troops = getTroopValue(player)\n\tlocal land = getLandValue(player)\n\t\n\tlocal density = troops/land\n\t\n\tif density >= HARD_LIMIT_MULTIPLIER then\n\t\tlocal newTroops = land * HARD_LIMIT_MULTIPLIER\n\t\tupdateTroopValue(player, newTroops)\n\t\treturn\n\tend\n\t\n\tlocal newTroops = troops + (land * 2) --* 12\n\n\tupdateTroopValue(player, newTroops)\nend\n\n-- Combat mechanics and territory management functions\n\n-- Function to calculate expansion cost\nfunction Calculate.calculateExpansionCost(pixelsToConquer)\n\treturn pixelsToConquer * CONQUER_COST_PER_PIXEL\nend\n\n\n-- Function to conquer new pixels\n-- this gets called inside Actions, not ActionHandler\n-- Function to conquer new pixels\nfunction Calculate.expandTerritory(player, pixelsToConquer, attackingTroops)\n\tlocal costToExpand = Calculate.calculateExpansionCost(pixelsToConquer)\n\tif attackingTroops >= costToExpand then\n\t\t-- send update to client\n\t\t--updateTroopValue(player, -costToExpand)\n\t\t\n\t\treturn true, attackingTroops - costToExpand -- Expansion successful, return remaining troops\n\telse\n\t\tlocal newAttackerTroops = getTroopValue(player)  + attackingTroops\n\t\t-- add remainder troops\n\t\tupdateTroopValue(player, newAttackerTroops)\n\n\t\treturn false, attackingTroops -- Not enough balance to expand, return remaining troops\n\tend\nend\n\n\n\n-- Function to calculate defending troop density per border pixel\nfunction Calculate.calculateBorderDensity(defenderTroops, defenderLand)\n\t--  it takes 2 to take out 1\n\tlocal density = (defenderTroops / defenderLand) * 2\n\treturn density\nend\n\n\n\n\nfunction Calculate.botAction(botId)\n\tlocal botTroops =  getTroopValue(botId)\n\tlocal botLand = getLandValue(botId)\n\t\n\tlocal density = (botTroops / botLand)\n\tif density < math.random(8,32) or botLand < 1 then\n\t\treturn false\n\tend\n\treturn true\nend\n\n\n\n\n-- Function to calculate attack losses considering border pixels and troop density\nfunction Calculate.calculateAttackLosses(playerDefender, attackingTroops, borderAmount)\n\t-- Calculate the defending troop density\n\tlocal playerTroops = getTroopValue(playerDefender)\n\tlocal defendingDensity = Calculate.calculateBorderDensity(playerTroops, getLandValue(playerDefender))\n\n\t-- Calculate the number of troops the attacker loses based on the density (assuming a 1:1 ratio)\n\t--local attackerLosses = 0\n\t--for i = 1, borderPixels do\n\t--\tif attackingTroops <= 0 then break end\n\n\tlocal attackerLosses = borderAmount * defendingDensity\n\t\n\tattackingTroops = attackingTroops - attackerLosses\n\t\n\tif attackingTroops < 0 then\n\t\treturn 0, 0\n\tend\n\t--end\n\t\n\t\n\t-- Calculate the number of troops the defender loses (1:0.5 ratio)\n\tlocal defenderLosses = math.floor(math.min(attackerLosses/2, playerTroops))\n\t\n\tif attackerLosses > playerTroops then\n\t\tlocal newAttackerLosses = math.min(attackerLosses,playerTroops)\n\n\t\t-- this is the leftover troops if you end up wiping out the enemy, these get added back!\n\t\tlocal regainedTroops = attackerLosses - newAttackerLosses\n\t\t\n\t\tlocal newTroops = getTroopValue(playerDefender)  + regainedTroops\n\t\tupdateTroopValue(playerDefender, newTroops)\n\t\treturn newAttackerLosses, defenderLosses\n\tend\n\t\n\t\n\treturn attackerLosses, defenderLosses\nend\n\n-- Function to perform an attack\nfunction Calculate.attack(playerAttacker, playerDefender, attackingTroops, borderAmount)\n\t-- ... existing logic\n\tlocal attackerLosses, defenderLosses = Calculate.calculateAttackLosses(playerDefender, attackingTroops, borderAmount)\n\n\t-- Update balances after the attack\n\tlocal newAttackerTroops = getTroopValue(playerAttacker)  - attackingTroops\n\tlocal newDefenderTroops = getTroopValue(playerDefender)  - defenderLosses\n\t\n\t-- update enemy\n\tupdateTroopValue(playerDefender, newDefenderTroops)\n\n\t-- Return the results of the attack and the remaining attacking troops vvv\n\treturn attackerLosses, defenderLosses, attackingTroops - attackerLosses\nend\n\n\nreturn Calculate"}]