[{"className":"LocalScript","name":"LocalScript","properties":{"Capabilities":{"type":"Enum","value":{"enumType":"SecurityCapabilities","value":""}},"Disabled":{"type":"bool","value":true},"LinkedSource":{"type":"Enum","value":{"enumType":"ContentId","value":""}},"RunContext":{"type":"Enum","value":{"enumType":"RunContext","value":"Legacy"}},"Source":{"type":"ProtectedString","value":"--!strict\ngame:GetService(\"TestService\"):Message(\"This game is using Re:Notify by Sezei / 0bBinary - V1.3A\");\n\nlocal TweenService = game:GetService('TweenService');\nlocal GUI = script.Parent;\n\nlocal InternalEvent:BindableEvent = GUI:FindFirstChild(\"InternalCommunication\") :: BindableEvent;\nlocal RemoteEvent:RemoteEvent = game:GetService(\"ReplicatedStorage\"):WaitForChild(\"ReNotifyEvent\") :: RemoteEvent;\nlocal RemoteFunction:RemoteFunction = game:GetService(\"ReplicatedStorage\"):WaitForChild(\"ReNotifyFunction\") :: RemoteFunction;\n\nlocal require = require;\nlocal Cardboard = require(script:FindFirstChild(\"CardBoard\"));\n\nlocal Listenings = {};\nInternalEvent.Event:Connect(function(Action, UID, Option)\n\tif Action == \"NotificationOptionSelected\" then\n\t\tif Listenings[UID] and type(Listenings[UID]) == \"function\" then\n\t\t\tListenings[UID](Option);\n\t\tend\n\t\tRemoteEvent:FireServer(\"NotificationOptionSelected\", UID, Option);\n\tend\nend);\n\n-- For some reason these values keep resetting, so we have to set them again.\nGUI.IgnoreGuiInset = true;\nGUI.ResetOnSpawn = false;\n\nlocal function ClearNotification(Notification:TextButton)\n\tNotification.Name = \"disappearing\"\n\t-- Remove the notification out of the screen\n\tlocal currentpos = Notification.Position;\n\tlocal targetpos = UDim2.new(currentpos.X.Scale + 2, currentpos.X.Offset, currentpos.Y.Scale, currentpos.Y.Offset);\n\tlocal tween = TweenService:Create(Notification, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = targetpos});\n\ttween:Play();\n\t-- Move any other notifications downwards\n\tfor _,v in GUI:GetChildren() do\n\t\tif v:IsA(\"TextButton\") then\n\t\t\tif v.Position.Y.Offset < Notification.Position.Y.Offset then\n\t\t\t\tlocal currentpos = v.Position;\n\t\t\t\tlocal targetpos = UDim2.new(currentpos.X.Scale, currentpos.X.Offset, currentpos.Y.Scale, currentpos.Y.Offset + 40);\n\t\t\t\tlocal tween = TweenService:Create(v, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = targetpos});\n\t\t\t\ttween:Play();\n\t\t\tend\n\t\tend\n\tend\n\t-- Delete the notification after the tween is done\n\ttask.wait(0.75);\n\tNotification:Destroy();\nend;\n\nlocal function PlaySound(AudioString : string) : nil\n\tlocal Sound = Instance.new(\"Sound\");\n\tSound.SoundId = \"rbxassetid://\" .. AudioString;\n\tSound.Parent = GUI;\n\tSound.Looped = false;\n\tif not Sound.IsLoaded then Sound.Loaded:Wait() end;\n\tSound:Play();\n\tSound.Ended:Connect(function()\n\t\tSound:Destroy();\n\tend);\n\n\treturn nil;\nend;\n\nlocal function CreateNotification(text:string, options:{[any?]: any?}?)\n\t--[[\n\tlocal UID = CreateUID();\n\tlocal Notification:TextButton = Assets:FindFirstChild(\"Notification\"):Clone() :: TextButton;\n\t--]]\n\n\tlocal Notification, UID = Cardboard(\"Notification\", GUI, {\n\t\t[\"Text\"] = text;\n\t});\n\n\tlocal Label:TextLabel = Notification:FindFirstChild(\"Label\") :: TextLabel;\n\n\tlocal Options:Frame = Notification:FindFirstChild(\"Options\") :: Frame;\n\tlocal PrimaryOption = nil;\n\tlocal TimedOutOption = nil;\n\tlocal PushingDown:boolean = false;\n\tlocal Clickable:boolean = true;\n\tlocal OnePosDown:boolean = false;\n\n\tNotification.Name = UID;\n\tNotification.Parent = GUI;\n\n\tif options then\n\t\t-- Avoid 'permanent' notifications; They MUST get a way to be removed.\n\t\tif typeof(options.Timeout) ~= \"number\" and typeof(options.Clickable) == \"boolean\" and options.Clickable == false then\n\t\t\toptions.Timeout = 30; -- This makes the notification last for 30 seconds.\n\t\t\t-- For addon devs: If you want a permanent notification, don't make the notification unclickable; It'll clutter the screen.\n\t\t\t-- You can use a hintbox instead for !setmessage, as it will not obscure the notifications box.\n\t\tend\n\n\t\tif options.Type and type(options.Type) == \"string\" then\n\t\t\tif string.lower(options.Type) == \"normal\" then\n\t\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t\t[\"BackgroundColor\"] = Color3.fromRGB(45, 45, 45);\n\t\t\t\t\t[\"TextColor\"] = Color3.fromRGB(255, 255, 255);\n\t\t\t\t});\n\t\t\telseif string.lower(options.Type) == \"warning\" or string.lower(options.Type) == \"warn\" then\n\t\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t\t[\"BackgroundColor\"] = Color3.fromRGB(45, 45, 45);\n\t\t\t\t\t[\"TextColor\"] = Color3.fromRGB(255, 127, 0);\n\t\t\t\t});\n\t\t\telseif string.lower(options.Type) == \"error\" then\n\t\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t\t[\"BackgroundColor\"] = Color3.fromRGB(45, 45, 45);\n\t\t\t\t\t[\"TextColor\"] = Color3.fromRGB(255, 60, 60);\n\t\t\t\t});\n\t\t\telseif string.lower(options.Type) == \"critical\" then\n\t\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t\t[\"BackgroundColor\"] = Color3.fromRGB(255, 60, 60);\n\t\t\t\t\t[\"TextColor\"] = Color3.fromRGB(255, 255, 255);\n\t\t\t\t});\n\t\t\t\tLabel.Font = Enum.Font.GothamBlack;\n\t\t\t\tPushingDown = true;\n\t\t\tend\n\t\tend\n\t\tif options.TextColor and typeof(options.TextColor) == \"Color3\" then\n\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t[\"TextColor\"] = options.TextColor;\n\t\t\t});\n\t\tend\n\t\tif options.BackgroundColor and typeof(options.BackgroundColor) == \"Color3\" then\n\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t[\"BackgroundColor\"] = options.BackgroundColor;\n\t\t\t});\n\t\tend\n\t\tif options.Timeout and typeof(options.Timeout) == \"number\" then\n\t\t\tlocal timer:Frame = Notification:FindFirstChild(\"Timer\") :: Frame;\n\t\t\ttimer:TweenSize(UDim2.new(0, 0, 0, 2), Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, options.Timeout, true);\n\t\t\ttimer.Visible = true;\n\t\t\ttask.spawn(function()\n\t\t\t\ttask.wait(options.Timeout + 0.1);\n\t\t\t\tif Notification.Parent then\n\t\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", UID, TimedOutOption or \"Timedout\");\n\t\t\t\t\tClearNotification(Notification);\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\t\tif options.PushLowest and type(options.PushLowest) == \"boolean\" then\n\t\t\tPushingDown = options.PushLowest;\n\t\tend\n\t\tif type(options.Clickable) == \"boolean\" then\n\t\t\tClickable = options.Clickable;\n\t\t\tNotification.AutoButtonColor = options.Clickable;\n\t\tend\n\t\tif options.Image and type(options.Image) == \"string\" then\n\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t[\"Icon\"] = options.Image;\n\t\t\t});\n\t\t\tLabel.Position = UDim2.new(0, 42, 0, 0);\n\t\t\tNotification.Image.Visible = true;\n\t\telse\n\t\t\tLabel.Position = UDim2.new(0, 10, 0, 0);\n\t\t\tNotification.Image.Visible = false;\n\t\tend\n\t\tif options.Sound and type(options.Sound) == \"string\" then\n\t\t\tPlaySound(options.Sound);\n\t\tend\n\t\tif options.Options and type(options.Options) == \"table\" then\n\t\t\tlocal SortedOptions = {};\n\t\t\tlocal checked = false;\n\t\t\tfor internalname, optionvalues in (options.Options) do\n\t\t\t\tif type(optionvalues) == \"string\" then\n\t\t\t\t\tSortedOptions[internalname] = optionvalues;\n\t\t\t\t\tif checked == false then\n\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tchecked = true;\n\t\t\t\telseif type(optionvalues) == \"table\" then\n\t\t\t\t\tSortedOptions[internalname] = internalname;\n\t\t\t\t\tif optionvalues.Text and (type(optionvalues.Text) == \"string\" or type(optionvalues.Text) == \"number\") then\n\t\t\t\t\t\tSortedOptions[internalname] = tostring(optionvalues.Text);\n\t\t\t\t\t\tif checked == false then\n\t\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tif optionvalues.Primary and type(optionvalues.Primary) == \"boolean\" and optionvalues.Primary == true then\n\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tif optionvalues.TimedOut and type(optionvalues.TimedOut) == \"boolean\" and optionvalues.TimedOut == true then\n\t\t\t\t\t\tTimedOutOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tchecked = true;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t-- Create the primary option\n\t\t\tlocal Button:TextButton = Options:FindFirstChild(\"PROMPT_DefaultButton\"):Clone() :: TextButton;\n\t\t\tButton.Name = PrimaryOption;\n\t\t\tButton.Text = SortedOptions[PrimaryOption];\n\t\t\tButton.Parent = Options;\n\t\t\tButton.Visible = true;\n\t\t\tButton.Size = UDim2.new(0, Button.TextBounds.X + 20, 0, 30);\n\t\t\tButton.MouseButton1Click:Connect(function()\n\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", UID, PrimaryOption);\n\t\t\t\tClearNotification(Notification);\n\t\t\tend);\n\n\t\t\t-- Create the other options\n\t\t\tfor internalname, text in (SortedOptions) do\n\t\t\t\tif internalname ~= PrimaryOption then\n\t\t\t\t\tlocal Button:TextButton = Options:FindFirstChild(\"PROMPT_Button\"):Clone() :: TextButton;\n\t\t\t\t\tButton.Name = internalname;\n\t\t\t\t\tButton.Text = text;\n\t\t\t\t\tButton.Parent = Options;\n\t\t\t\t\tButton.Visible = true;\n\t\t\t\t\tButton.Size = UDim2.new(0, Button.TextBounds.X + 10, 0, 30);\n\t\t\t\t\tButton.MouseButton1Click:Connect(function()\n\t\t\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", UID, internalname);\n\t\t\t\t\t\tClearNotification(Notification);\n\t\t\t\t\tend);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend;\n\n\t-- Combine the size of the label and the options\n\tlocal ListLayout = Options:FindFirstChild(\"UIListLayout\") :: UIListLayout;\n\tlocal XSize = Label.TextBounds.X + ListLayout.AbsoluteContentSize.X + 35;\n\n\tif ListLayout.AbsoluteContentSize.X < 2 then\n\t\tXSize = Label.TextBounds.X + 20;\n\tend\n\n\tif type(options) == \"table\" and options.Image and type(options.Image) == \"string\" then\n\t\tXSize = XSize + 32;\n\tend\n\n\tNotification.Size = UDim2.new(0, math.max(XSize, 250), 0, 36);\n\n\t-- Find where the notification should go if PushLowest is disabled\n\tif not PushingDown then\n\t\tlocal NotificationCount = -1;\n\t\tfor _, notification in (GUI:GetChildren()) do\n\t\t\tif notification:IsA(\"TextButton\") and notification.Name ~= \"disappearing\" then\n\t\t\t\tNotificationCount = NotificationCount + 1;\n\t\t\tend\n\t\tend\n\t\tlocal NotificationPosition = UDim2.new(1, -10, 1, (-40 * NotificationCount - 82));\n\t\tNotification.Position = NotificationPosition;\n\telse\n\t\tlocal children = GUI:GetChildren();\n\t\tfor _,v in (children) do\n\t\t\tif v:IsA(\"TextButton\") and v.Name ~= UID and v.Name ~= \"disappearing\" then\n\t\t\t\tlocal currentpos = v.Position;\n\t\t\t\tlocal targetpos = UDim2.new(currentpos.X.Scale, currentpos.X.Offset, currentpos.Y.Scale, currentpos.Y.Offset - 40);\n\t\t\t\tlocal tween = TweenService:Create(v, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = targetpos});\n\t\t\t\ttween:Play();\n\t\t\tend\n\t\tend\n\tend\n\n\t-- On notification click (not on the options)\n\tNotification.MouseButton1Click:Connect(function()\n\t\tif not Clickable then\n\t\t\treturn;\n\t\tend\n\t\tInternalEvent:Fire(\"NotificationOptionSelected\", UID, PrimaryOption or \"Clicked\");\n\t\tClickable = false;\n\t\tClearNotification(Notification);\n\tend);\n\n\tNotification.Visible = true;\n\n\treturn Notification, UID;\nend;\n\nlocal function UpdateNotification(Notification:TextButton, Changes:any)\n\tif type(Notification) == 'string' then\n\t\t-- Find the notification\n\t\tNotification = GUI:FindFirstChild(Notification) :: TextButton;\n\tend\n\t\n\tif not Notification then return end;\n\tlocal Label:TextLabel = Notification:FindFirstChild(\"Label\") :: TextLabel;\n\tlocal Options:Frame = Notification:FindFirstChild(\"Options\") :: Frame;\n\tif type(Changes) == \"string\" then\n\t\tLabel.Text = Changes;\n\telseif type(Changes) == \"table\" then\n\t\tif Changes.Text and type(Changes.Text) == \"string\" then\n\t\t\tLabel.Text = Changes.Text;\n\t\tend\n\t\tif Changes.Image and type(Changes.Image) == \"string\" then\n\t\t\tif Changes.Image ~= \"remove\" then\n\t\t\t\tlocal Image:ImageLabel = Notification:FindFirstChild(\"Image\") :: ImageLabel;\n\t\t\t\tImage.Image = Changes.Image;\n\t\t\t\tImage.Visible = true;\n\t\t\t\tLabel.Position = UDim2.new(0, 42, 0, 0);\n\t\t\telse\n\t\t\t\tlocal Image:ImageLabel = Notification:FindFirstChild(\"Image\") :: ImageLabel;\n\t\t\t\tImage.Image = \"\";\n\t\t\t\tImage.Visible = false;\n\t\t\t\tLabel.Position = UDim2.new(0, 10, 0, 0);\n\t\t\tend\n\t\tend\n\t\tif Changes.TextColor and typeof(Changes.TextColor) == \"Color3\" then\n\t\t\tLabel.TextColor3 = Changes.TextColor;\n\t\tend\n\t\tif Changes.BackgroundColor and typeof(Changes.BackgroundColor) == \"Color3\" then\n\t\t\tNotification.BackgroundColor3 = Changes.BackgroundColor;\n\t\tend\n\t\tif Changes.Options and type(Changes.Options) == \"table\" then\n\t\t\t-- Clear the options\n\t\t\tfor _, option in (Options:GetChildren()) do\n\t\t\t\tif option:IsA(\"TextButton\") and option.Name ~= \"PROMPT_DefaultButton\" and option.Name ~= \"PROMPT_Button\" then\n\t\t\t\t\toption:Destroy();\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tlocal SortedOptions = {};\n\t\t\tlocal PrimaryOption;\n\t\t\tlocal TimedOutOption;\n\t\t\tlocal checked = false;\n\t\t\tfor internalname, optionvalues in (Changes.Options) do\n\t\t\t\tif type(optionvalues) == \"table\" then\n\t\t\t\t\tif optionvalues.Text and type(optionvalues.Text) == \"string\" then\n\t\t\t\t\t\tSortedOptions[internalname] = tostring(optionvalues.Text);\n\t\t\t\t\t\tif checked == false then\n\t\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tif optionvalues.Primary and type(optionvalues.Primary) == \"boolean\" and optionvalues.Primary == true then\n\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tif optionvalues.TimedOut and type(optionvalues.TimedOut) == \"boolean\" and optionvalues.TimedOut == true then\n\t\t\t\t\t\tTimedOutOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tchecked = true;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t-- Create the primary option\n\t\t\tlocal Button:TextButton = Options:FindFirstChild(\"PROMPT_DefaultButton\"):Clone() :: TextButton;\n\t\t\tButton.Name = PrimaryOption;\n\t\t\tButton.Text = SortedOptions[PrimaryOption];\n\t\t\tButton.Parent = Options;\n\t\t\tButton.Visible = true;\n\t\t\tButton.Size = UDim2.new(0, Button.TextBounds.X + 20, 0, 30);\n\t\t\tButton.MouseButton1Click:Connect(function()\n\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", Notification.Name, PrimaryOption);\n\t\t\t\tClearNotification(Notification);\n\t\t\tend);\n\n\t\t\t-- Create the other options\n\t\t\tfor internalname, text in (SortedOptions) do\n\t\t\t\tif internalname ~= PrimaryOption then\n\t\t\t\t\tlocal Button:TextButton = Options:FindFirstChild(\"PROMPT_Button\"):Clone() :: TextButton;\n\t\t\t\t\tButton.Name = internalname;\n\t\t\t\t\tButton.Text = text;\n\t\t\t\t\tButton.Parent = Options;\n\t\t\t\t\tButton.Visible = true;\n\t\t\t\t\tButton.Size = UDim2.new(0, Button.TextBounds.X + 10, 0, 30);\n\t\t\t\t\tButton.MouseButton1Click:Connect(function()\n\t\t\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", Notification.Name, internalname);\n\t\t\t\t\t\tClearNotification(Notification);\n\t\t\t\t\tend);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\t-- Resize the notification\n\tlocal ListLayout = Options:FindFirstChild(\"UIListLayout\") :: UIListLayout;\n\tlocal XSize = Label.TextBounds.X + ListLayout.AbsoluteContentSize.X + 35;\n\n\tif ListLayout.AbsoluteContentSize.X < 2 then\n\t\tXSize = Label.TextBounds.X + 20;\n\tend\n\n\tif type(Changes) == \"table\" and Changes.Image and type(Changes.Image) == \"string\" then\n\t\tXSize = XSize + 32;\n\tend\n\n\tNotification:TweenSize(UDim2.new(0, XSize, 0, 36), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.3, true);\nend;\n\n-- Connect the remotes.\nRemoteEvent.OnClientEvent:Connect(function(...)\n\tlocal Arguments = {...};\n\tlocal EventName = Arguments[1];\n\ttable.remove(Arguments, 1);\n\n\tif EventName == \"Notify\" then\n\t\tCreateNotification(tostring(Arguments[1]), Arguments[2]);\n\telseif EventName == \"UpdateNotification\" then\n\t\tUpdateNotification(Arguments[1], Arguments[2]);\n\telseif EventName == \"ClearNotification\" then\n\t\tClearNotification(Arguments[1]);\n\tend\nend);\n\nRemoteFunction.OnClientInvoke = function(...)\n\tlocal Arguments = {...};\n\tlocal FunctionName = Arguments[1];\n\ttable.remove(Arguments, 1);\n\n\tif FunctionName == \"NotificationExists\" then\n\t\treturn (not (not Cardboard:FindAsset(Arguments[1])));\n\telseif FunctionName == \"Notify\" then -- If used in a function, it usually means the server is awaiting for a response from the player due to the .Options; Return an UUID to the server.\n\t\tlocal _, UID = CreateNotification(tostring(Arguments[1]), Arguments[2]);\n\t\treturn UID;\n\tend\nend;"}},"referenceId":"0000004e-873d-014f-a6b9-00005f459ad5","source":"--!strict\ngame:GetService(\"TestService\"):Message(\"This game is using Re:Notify by Sezei / 0bBinary - V1.3A\");\n\nlocal TweenService = game:GetService('TweenService');\nlocal GUI = script.Parent;\n\nlocal InternalEvent:BindableEvent = GUI:FindFirstChild(\"InternalCommunication\") :: BindableEvent;\nlocal RemoteEvent:RemoteEvent = game:GetService(\"ReplicatedStorage\"):WaitForChild(\"ReNotifyEvent\") :: RemoteEvent;\nlocal RemoteFunction:RemoteFunction = game:GetService(\"ReplicatedStorage\"):WaitForChild(\"ReNotifyFunction\") :: RemoteFunction;\n\nlocal require = require;\nlocal Cardboard = require(script:FindFirstChild(\"CardBoard\"));\n\nlocal Listenings = {};\nInternalEvent.Event:Connect(function(Action, UID, Option)\n\tif Action == \"NotificationOptionSelected\" then\n\t\tif Listenings[UID] and type(Listenings[UID]) == \"function\" then\n\t\t\tListenings[UID](Option);\n\t\tend\n\t\tRemoteEvent:FireServer(\"NotificationOptionSelected\", UID, Option);\n\tend\nend);\n\n-- For some reason these values keep resetting, so we have to set them again.\nGUI.IgnoreGuiInset = true;\nGUI.ResetOnSpawn = false;\n\nlocal function ClearNotification(Notification:TextButton)\n\tNotification.Name = \"disappearing\"\n\t-- Remove the notification out of the screen\n\tlocal currentpos = Notification.Position;\n\tlocal targetpos = UDim2.new(currentpos.X.Scale + 2, currentpos.X.Offset, currentpos.Y.Scale, currentpos.Y.Offset);\n\tlocal tween = TweenService:Create(Notification, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position = targetpos});\n\ttween:Play();\n\t-- Move any other notifications downwards\n\tfor _,v in GUI:GetChildren() do\n\t\tif v:IsA(\"TextButton\") then\n\t\t\tif v.Position.Y.Offset < Notification.Position.Y.Offset then\n\t\t\t\tlocal currentpos = v.Position;\n\t\t\t\tlocal targetpos = UDim2.new(currentpos.X.Scale, currentpos.X.Offset, currentpos.Y.Scale, currentpos.Y.Offset + 40);\n\t\t\t\tlocal tween = TweenService:Create(v, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = targetpos});\n\t\t\t\ttween:Play();\n\t\t\tend\n\t\tend\n\tend\n\t-- Delete the notification after the tween is done\n\ttask.wait(0.75);\n\tNotification:Destroy();\nend;\n\nlocal function PlaySound(AudioString : string) : nil\n\tlocal Sound = Instance.new(\"Sound\");\n\tSound.SoundId = \"rbxassetid://\" .. AudioString;\n\tSound.Parent = GUI;\n\tSound.Looped = false;\n\tif not Sound.IsLoaded then Sound.Loaded:Wait() end;\n\tSound:Play();\n\tSound.Ended:Connect(function()\n\t\tSound:Destroy();\n\tend);\n\n\treturn nil;\nend;\n\nlocal function CreateNotification(text:string, options:{[any?]: any?}?)\n\t--[[\n\tlocal UID = CreateUID();\n\tlocal Notification:TextButton = Assets:FindFirstChild(\"Notification\"):Clone() :: TextButton;\n\t--]]\n\n\tlocal Notification, UID = Cardboard(\"Notification\", GUI, {\n\t\t[\"Text\"] = text;\n\t});\n\n\tlocal Label:TextLabel = Notification:FindFirstChild(\"Label\") :: TextLabel;\n\n\tlocal Options:Frame = Notification:FindFirstChild(\"Options\") :: Frame;\n\tlocal PrimaryOption = nil;\n\tlocal TimedOutOption = nil;\n\tlocal PushingDown:boolean = false;\n\tlocal Clickable:boolean = true;\n\tlocal OnePosDown:boolean = false;\n\n\tNotification.Name = UID;\n\tNotification.Parent = GUI;\n\n\tif options then\n\t\t-- Avoid 'permanent' notifications; They MUST get a way to be removed.\n\t\tif typeof(options.Timeout) ~= \"number\" and typeof(options.Clickable) == \"boolean\" and options.Clickable == false then\n\t\t\toptions.Timeout = 30; -- This makes the notification last for 30 seconds.\n\t\t\t-- For addon devs: If you want a permanent notification, don't make the notification unclickable; It'll clutter the screen.\n\t\t\t-- You can use a hintbox instead for !setmessage, as it will not obscure the notifications box.\n\t\tend\n\n\t\tif options.Type and type(options.Type) == \"string\" then\n\t\t\tif string.lower(options.Type) == \"normal\" then\n\t\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t\t[\"BackgroundColor\"] = Color3.fromRGB(45, 45, 45);\n\t\t\t\t\t[\"TextColor\"] = Color3.fromRGB(255, 255, 255);\n\t\t\t\t});\n\t\t\telseif string.lower(options.Type) == \"warning\" or string.lower(options.Type) == \"warn\" then\n\t\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t\t[\"BackgroundColor\"] = Color3.fromRGB(45, 45, 45);\n\t\t\t\t\t[\"TextColor\"] = Color3.fromRGB(255, 127, 0);\n\t\t\t\t});\n\t\t\telseif string.lower(options.Type) == \"error\" then\n\t\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t\t[\"BackgroundColor\"] = Color3.fromRGB(45, 45, 45);\n\t\t\t\t\t[\"TextColor\"] = Color3.fromRGB(255, 60, 60);\n\t\t\t\t});\n\t\t\telseif string.lower(options.Type) == \"critical\" then\n\t\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t\t[\"BackgroundColor\"] = Color3.fromRGB(255, 60, 60);\n\t\t\t\t\t[\"TextColor\"] = Color3.fromRGB(255, 255, 255);\n\t\t\t\t});\n\t\t\t\tLabel.Font = Enum.Font.GothamBlack;\n\t\t\t\tPushingDown = true;\n\t\t\tend\n\t\tend\n\t\tif options.TextColor and typeof(options.TextColor) == \"Color3\" then\n\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t[\"TextColor\"] = options.TextColor;\n\t\t\t});\n\t\tend\n\t\tif options.BackgroundColor and typeof(options.BackgroundColor) == \"Color3\" then\n\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t[\"BackgroundColor\"] = options.BackgroundColor;\n\t\t\t});\n\t\tend\n\t\tif options.Timeout and typeof(options.Timeout) == \"number\" then\n\t\t\tlocal timer:Frame = Notification:FindFirstChild(\"Timer\") :: Frame;\n\t\t\ttimer:TweenSize(UDim2.new(0, 0, 0, 2), Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, options.Timeout, true);\n\t\t\ttimer.Visible = true;\n\t\t\ttask.spawn(function()\n\t\t\t\ttask.wait(options.Timeout + 0.1);\n\t\t\t\tif Notification.Parent then\n\t\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", UID, TimedOutOption or \"Timedout\");\n\t\t\t\t\tClearNotification(Notification);\n\t\t\t\tend\n\t\t\tend)\n\t\tend\n\t\tif options.PushLowest and type(options.PushLowest) == \"boolean\" then\n\t\t\tPushingDown = options.PushLowest;\n\t\tend\n\t\tif type(options.Clickable) == \"boolean\" then\n\t\t\tClickable = options.Clickable;\n\t\t\tNotification.AutoButtonColor = options.Clickable;\n\t\tend\n\t\tif options.Image and type(options.Image) == \"string\" then\n\t\t\tCardboard:UpdateAsset(UID, {\n\t\t\t\t[\"Icon\"] = options.Image;\n\t\t\t});\n\t\t\tLabel.Position = UDim2.new(0, 42, 0, 0);\n\t\t\tNotification.Image.Visible = true;\n\t\telse\n\t\t\tLabel.Position = UDim2.new(0, 10, 0, 0);\n\t\t\tNotification.Image.Visible = false;\n\t\tend\n\t\tif options.Sound and type(options.Sound) == \"string\" then\n\t\t\tPlaySound(options.Sound);\n\t\tend\n\t\tif options.Options and type(options.Options) == \"table\" then\n\t\t\tlocal SortedOptions = {};\n\t\t\tlocal checked = false;\n\t\t\tfor internalname, optionvalues in (options.Options) do\n\t\t\t\tif type(optionvalues) == \"string\" then\n\t\t\t\t\tSortedOptions[internalname] = optionvalues;\n\t\t\t\t\tif checked == false then\n\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tchecked = true;\n\t\t\t\telseif type(optionvalues) == \"table\" then\n\t\t\t\t\tSortedOptions[internalname] = internalname;\n\t\t\t\t\tif optionvalues.Text and (type(optionvalues.Text) == \"string\" or type(optionvalues.Text) == \"number\") then\n\t\t\t\t\t\tSortedOptions[internalname] = tostring(optionvalues.Text);\n\t\t\t\t\t\tif checked == false then\n\t\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tif optionvalues.Primary and type(optionvalues.Primary) == \"boolean\" and optionvalues.Primary == true then\n\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tif optionvalues.TimedOut and type(optionvalues.TimedOut) == \"boolean\" and optionvalues.TimedOut == true then\n\t\t\t\t\t\tTimedOutOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tchecked = true;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t-- Create the primary option\n\t\t\tlocal Button:TextButton = Options:FindFirstChild(\"PROMPT_DefaultButton\"):Clone() :: TextButton;\n\t\t\tButton.Name = PrimaryOption;\n\t\t\tButton.Text = SortedOptions[PrimaryOption];\n\t\t\tButton.Parent = Options;\n\t\t\tButton.Visible = true;\n\t\t\tButton.Size = UDim2.new(0, Button.TextBounds.X + 20, 0, 30);\n\t\t\tButton.MouseButton1Click:Connect(function()\n\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", UID, PrimaryOption);\n\t\t\t\tClearNotification(Notification);\n\t\t\tend);\n\n\t\t\t-- Create the other options\n\t\t\tfor internalname, text in (SortedOptions) do\n\t\t\t\tif internalname ~= PrimaryOption then\n\t\t\t\t\tlocal Button:TextButton = Options:FindFirstChild(\"PROMPT_Button\"):Clone() :: TextButton;\n\t\t\t\t\tButton.Name = internalname;\n\t\t\t\t\tButton.Text = text;\n\t\t\t\t\tButton.Parent = Options;\n\t\t\t\t\tButton.Visible = true;\n\t\t\t\t\tButton.Size = UDim2.new(0, Button.TextBounds.X + 10, 0, 30);\n\t\t\t\t\tButton.MouseButton1Click:Connect(function()\n\t\t\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", UID, internalname);\n\t\t\t\t\t\tClearNotification(Notification);\n\t\t\t\t\tend);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend;\n\n\t-- Combine the size of the label and the options\n\tlocal ListLayout = Options:FindFirstChild(\"UIListLayout\") :: UIListLayout;\n\tlocal XSize = Label.TextBounds.X + ListLayout.AbsoluteContentSize.X + 35;\n\n\tif ListLayout.AbsoluteContentSize.X < 2 then\n\t\tXSize = Label.TextBounds.X + 20;\n\tend\n\n\tif type(options) == \"table\" and options.Image and type(options.Image) == \"string\" then\n\t\tXSize = XSize + 32;\n\tend\n\n\tNotification.Size = UDim2.new(0, math.max(XSize, 250), 0, 36);\n\n\t-- Find where the notification should go if PushLowest is disabled\n\tif not PushingDown then\n\t\tlocal NotificationCount = -1;\n\t\tfor _, notification in (GUI:GetChildren()) do\n\t\t\tif notification:IsA(\"TextButton\") and notification.Name ~= \"disappearing\" then\n\t\t\t\tNotificationCount = NotificationCount + 1;\n\t\t\tend\n\t\tend\n\t\tlocal NotificationPosition = UDim2.new(1, -10, 1, (-40 * NotificationCount - 82));\n\t\tNotification.Position = NotificationPosition;\n\telse\n\t\tlocal children = GUI:GetChildren();\n\t\tfor _,v in (children) do\n\t\t\tif v:IsA(\"TextButton\") and v.Name ~= UID and v.Name ~= \"disappearing\" then\n\t\t\t\tlocal currentpos = v.Position;\n\t\t\t\tlocal targetpos = UDim2.new(currentpos.X.Scale, currentpos.X.Offset, currentpos.Y.Scale, currentpos.Y.Offset - 40);\n\t\t\t\tlocal tween = TweenService:Create(v, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = targetpos});\n\t\t\t\ttween:Play();\n\t\t\tend\n\t\tend\n\tend\n\n\t-- On notification click (not on the options)\n\tNotification.MouseButton1Click:Connect(function()\n\t\tif not Clickable then\n\t\t\treturn;\n\t\tend\n\t\tInternalEvent:Fire(\"NotificationOptionSelected\", UID, PrimaryOption or \"Clicked\");\n\t\tClickable = false;\n\t\tClearNotification(Notification);\n\tend);\n\n\tNotification.Visible = true;\n\n\treturn Notification, UID;\nend;\n\nlocal function UpdateNotification(Notification:TextButton, Changes:any)\n\tif type(Notification) == 'string' then\n\t\t-- Find the notification\n\t\tNotification = GUI:FindFirstChild(Notification) :: TextButton;\n\tend\n\t\n\tif not Notification then return end;\n\tlocal Label:TextLabel = Notification:FindFirstChild(\"Label\") :: TextLabel;\n\tlocal Options:Frame = Notification:FindFirstChild(\"Options\") :: Frame;\n\tif type(Changes) == \"string\" then\n\t\tLabel.Text = Changes;\n\telseif type(Changes) == \"table\" then\n\t\tif Changes.Text and type(Changes.Text) == \"string\" then\n\t\t\tLabel.Text = Changes.Text;\n\t\tend\n\t\tif Changes.Image and type(Changes.Image) == \"string\" then\n\t\t\tif Changes.Image ~= \"remove\" then\n\t\t\t\tlocal Image:ImageLabel = Notification:FindFirstChild(\"Image\") :: ImageLabel;\n\t\t\t\tImage.Image = Changes.Image;\n\t\t\t\tImage.Visible = true;\n\t\t\t\tLabel.Position = UDim2.new(0, 42, 0, 0);\n\t\t\telse\n\t\t\t\tlocal Image:ImageLabel = Notification:FindFirstChild(\"Image\") :: ImageLabel;\n\t\t\t\tImage.Image = \"\";\n\t\t\t\tImage.Visible = false;\n\t\t\t\tLabel.Position = UDim2.new(0, 10, 0, 0);\n\t\t\tend\n\t\tend\n\t\tif Changes.TextColor and typeof(Changes.TextColor) == \"Color3\" then\n\t\t\tLabel.TextColor3 = Changes.TextColor;\n\t\tend\n\t\tif Changes.BackgroundColor and typeof(Changes.BackgroundColor) == \"Color3\" then\n\t\t\tNotification.BackgroundColor3 = Changes.BackgroundColor;\n\t\tend\n\t\tif Changes.Options and type(Changes.Options) == \"table\" then\n\t\t\t-- Clear the options\n\t\t\tfor _, option in (Options:GetChildren()) do\n\t\t\t\tif option:IsA(\"TextButton\") and option.Name ~= \"PROMPT_DefaultButton\" and option.Name ~= \"PROMPT_Button\" then\n\t\t\t\t\toption:Destroy();\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tlocal SortedOptions = {};\n\t\t\tlocal PrimaryOption;\n\t\t\tlocal TimedOutOption;\n\t\t\tlocal checked = false;\n\t\t\tfor internalname, optionvalues in (Changes.Options) do\n\t\t\t\tif type(optionvalues) == \"table\" then\n\t\t\t\t\tif optionvalues.Text and type(optionvalues.Text) == \"string\" then\n\t\t\t\t\t\tSortedOptions[internalname] = tostring(optionvalues.Text);\n\t\t\t\t\t\tif checked == false then\n\t\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tif optionvalues.Primary and type(optionvalues.Primary) == \"boolean\" and optionvalues.Primary == true then\n\t\t\t\t\t\tPrimaryOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tif optionvalues.TimedOut and type(optionvalues.TimedOut) == \"boolean\" and optionvalues.TimedOut == true then\n\t\t\t\t\t\tTimedOutOption = internalname;\n\t\t\t\t\tend\n\t\t\t\t\tchecked = true;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\t-- Create the primary option\n\t\t\tlocal Button:TextButton = Options:FindFirstChild(\"PROMPT_DefaultButton\"):Clone() :: TextButton;\n\t\t\tButton.Name = PrimaryOption;\n\t\t\tButton.Text = SortedOptions[PrimaryOption];\n\t\t\tButton.Parent = Options;\n\t\t\tButton.Visible = true;\n\t\t\tButton.Size = UDim2.new(0, Button.TextBounds.X + 20, 0, 30);\n\t\t\tButton.MouseButton1Click:Connect(function()\n\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", Notification.Name, PrimaryOption);\n\t\t\t\tClearNotification(Notification);\n\t\t\tend);\n\n\t\t\t-- Create the other options\n\t\t\tfor internalname, text in (SortedOptions) do\n\t\t\t\tif internalname ~= PrimaryOption then\n\t\t\t\t\tlocal Button:TextButton = Options:FindFirstChild(\"PROMPT_Button\"):Clone() :: TextButton;\n\t\t\t\t\tButton.Name = internalname;\n\t\t\t\t\tButton.Text = text;\n\t\t\t\t\tButton.Parent = Options;\n\t\t\t\t\tButton.Visible = true;\n\t\t\t\t\tButton.Size = UDim2.new(0, Button.TextBounds.X + 10, 0, 30);\n\t\t\t\t\tButton.MouseButton1Click:Connect(function()\n\t\t\t\t\t\tInternalEvent:Fire(\"NotificationOptionSelected\", Notification.Name, internalname);\n\t\t\t\t\t\tClearNotification(Notification);\n\t\t\t\t\tend);\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\t-- Resize the notification\n\tlocal ListLayout = Options:FindFirstChild(\"UIListLayout\") :: UIListLayout;\n\tlocal XSize = Label.TextBounds.X + ListLayout.AbsoluteContentSize.X + 35;\n\n\tif ListLayout.AbsoluteContentSize.X < 2 then\n\t\tXSize = Label.TextBounds.X + 20;\n\tend\n\n\tif type(Changes) == \"table\" and Changes.Image and type(Changes.Image) == \"string\" then\n\t\tXSize = XSize + 32;\n\tend\n\n\tNotification:TweenSize(UDim2.new(0, XSize, 0, 36), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.3, true);\nend;\n\n-- Connect the remotes.\nRemoteEvent.OnClientEvent:Connect(function(...)\n\tlocal Arguments = {...};\n\tlocal EventName = Arguments[1];\n\ttable.remove(Arguments, 1);\n\n\tif EventName == \"Notify\" then\n\t\tCreateNotification(tostring(Arguments[1]), Arguments[2]);\n\telseif EventName == \"UpdateNotification\" then\n\t\tUpdateNotification(Arguments[1], Arguments[2]);\n\telseif EventName == \"ClearNotification\" then\n\t\tClearNotification(Arguments[1]);\n\tend\nend);\n\nRemoteFunction.OnClientInvoke = function(...)\n\tlocal Arguments = {...};\n\tlocal FunctionName = Arguments[1];\n\ttable.remove(Arguments, 1);\n\n\tif FunctionName == \"NotificationExists\" then\n\t\treturn (not (not Cardboard:FindAsset(Arguments[1])));\n\telseif FunctionName == \"Notify\" then -- If used in a function, it usually means the server is awaiting for a response from the player due to the .Options; Return an UUID to the server.\n\t\tlocal _, UID = CreateNotification(tostring(Arguments[1]), Arguments[2]);\n\t\treturn UID;\n\tend\nend;"}]