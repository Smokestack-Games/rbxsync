[{"className":"ModuleScript","name":"CardBoard","parentId":"0000004f-48d1-43c1-ee98-000068ceda7c","path":"ServerScriptService.MainModule.Re:NotifyClient.LocalScript.CardBoard","properties":{"Capabilities":{"type":"Enum","value":{"enumType":"SecurityCapabilities","value":""}},"LinkedSource":{"type":"Enum","value":{"enumType":"ContentId","value":""}},"Source":{"type":"ProtectedString","value":"--!strict\n-- Cardboard is the UI handler for NxEngine2; It is responsible for using the existing assets to create a UI for the game.\n-- Otherwise, it can be used for editing existing UIs by checking for a '.cb' module inside the assets which will include the UI structure.\n-- This is the replacement of NanoWorks, which is Nano's UI handler.\n\n-- Template for .cb modules;\n--[[\n    {\n        [Property] = {Table of expected instances, Property, DefaultValue, ExpectedType?};\n    }\n]]\n\n-- Example for a .cb module (Hint module);\n--[[\nreturn {\n\t[\"Title\"] = {\n\t\t{\n\t\t\tscript.Parent.Title;\n\t\t};\n\t\t\"Text\";\n\t\t\"This is a title.\";\n\t\t\"string\";\n\t};\n\t[\"Content\"] = {\n\t\t{\n\t\t\tscript.Parent.Content;\n\t\t};\n\t\t\"Text\";\n\t\t\"This is some content.\";\n\t\t\"string\";\n\t};\n}\n]] --> This is the expected structure for a .cb module. It is a table with the property names as keys, and the values are tables which follow the structure of {Instances, Property, DefaultValue and ExpectedType}.\n\n-- If one does not exist, it will be attempted to be created locally.\n\nlocal Cardboard = {};\n\nlocal Players = game:GetService(\"Players\");\nlocal UserInputService = game:GetService(\"UserInputService\");\nlocal RunService = game:GetService(\"RunService\");\nlocal TweenService = game:GetService(\"TweenService\");\nlocal HttpService = game:GetService(\"HttpService\"); -- Used for JSON encoding/decoding.\nlocal Assets = script:FindFirstAncestorWhichIsA(\"ScreenGui\"):FindFirstChild(\"Assets\");\n\nlocal LocalPlayer = Players.LocalPlayer;\nlocal Mouse = LocalPlayer:GetMouse();\n\nlocal AssetProperties = {}; -- Cache for .cb modules so they won't have to be loaded again.\nlocal CreatedAssets = {}; -- Cache for assets that have been created; Mainly to store used UUIDs.\n\nlocal function CreateUID()\n\tlocal UID = \"\";\n\tfor i = 1, math.random(24, 32) do\n\t\tUID = UID .. string.char(math.random(65, 90));\n\tend\n\treturn UID;\nend\n\n-- Cardboard( AssetType: string, Parent: Instance, [Properties: table] ); Returns: Asset <Instance>, UUID <string>\nfunction Cardboard.new(AssetType, Parent, Properties)\n\t-- Generate a UUID for the asset.\n\tlocal UUID = CreateUID();\n\t\n\tif not Properties then Properties = {}; end;\n\n\tif not Assets:FindFirstChild(AssetType) then\n\t\terror(\"AssetType '\"..AssetType..\"' does not exist in the Assets folder. Does it exist?\");\n\tend;\n\n\t-- Create the asset.\n\tlocal Asset = Assets[AssetType]:Clone();\n\tAsset.Parent = Parent;\n\n\t-- Structure the asset according to the .cb module.\n\tlocal cb = nil;\n\n\tif AssetProperties[UUID] then\n\t\tcb = AssetProperties[UUID];\n\telseif Asset:FindFirstChild(\".cb\") then\n\t\tlocal cbModule = Asset:FindFirstChild(\".cb\");\n\t\tif cbModule and cbModule:IsA(\"ModuleScript\") then\n\t\t\tcb = require(cbModule) :: {[any?]:any?};\n\t\t\tAssetProperties[UUID] = cb;\n\t\tend;\n\tend;\n\n\tif cb then\n\t\tfor Key:string, Data:any in pairs(cb) do\n\t\t\tlocal Instances = Data[1];\n\t\t\tlocal Property = Data[2];\n\t\t\tlocal DefaultValue = Data[3];\n\t\t\tlocal ExpectedType = Data[4];\n\n\t\t\tif not Properties[Key] then\n\t\t\t\tProperties[Key] = DefaultValue;\n\t\t\tend;\n\n\t\t\tif ExpectedType and string.lower(typeof(Properties[Key])) ~= string.lower(ExpectedType) then\n\t\t\t\terror(\"Expected type '\"..ExpectedType..\"' for property '\"..Key..\"', got '\"..typeof(Properties[Key])..\"' instead.\");\n\t\t\tend;\n\n\t\t\tfor _, Instance in pairs(Instances) do\n\t\t\t\tlocal s,f = pcall(function()\n\t\t\t\t\tInstance[Property] = Properties[Key];\n\t\t\t\tend);\n\t\t\t\tif not s then\n\t\t\t\t\twarn(\"Failed to set property '\"..Key..\"' to '\"..tostring(Properties[Key])..\"' for instance '\"..Instance.Name..\"'.\");\n\t\t\t\tend;\n\t\t\tend;\n\t\tend;\n\tend;\n\t\n\t-- Add the asset into the CreatedAssets table.\n\tCreatedAssets[UUID] = {Asset, AssetType};\n\t\n\t-- Make the asset visible.\n\tAsset.Visible = true;\n\n\t-- Return the asset and the UUID.\n\treturn Asset, UUID;\nend;\n\n-- Cardboard:FindAsset( UUID: string ); Returns: StoredAsset <table{Asset, AssetType}>\nfunction Cardboard:FindAsset(UUID)\n\treturn CreatedAssets[UUID] or {nil, \"\"};\nend;\n\n-- Cardboard:UpdateAsset( UUID: string, NewProperties: table ); Returns: Success <boolean>\nfunction Cardboard:UpdateAsset(UUID, NewProperties)\n\tlocal StoredAsset = self:FindAsset(UUID);\n\tlocal Asset = StoredAsset[1];\n\tlocal AssetType = StoredAsset[2];\n\n\tif not Asset then\n\t\treturn false;\n\tend;\n\n\tlocal cb = nil;\n\tif AssetProperties[UUID] then\n\t\tcb = AssetProperties[UUID];\n\telse\n\t\tlocal cbModule = Asset:FindFirstChild(\".cb\");\n\t\tif cbModule and cbModule:IsA(\"ModuleScript\") then\n\t\t\tcb = require(cbModule) :: ModuleScript;\n\t\t\tAssetProperties[UUID] = cb;\n\t\tend;\n\tend;\n\n\tif cb then\n\t\tfor Key:string, Data:any in pairs(cb) do\n\t\t\tlocal Instances = Data[1];\n\t\t\tlocal Property = Data[2];\n\t\t\tlocal DefaultValue = Data[3];\n\t\t\tlocal ExpectedType = Data[4];\n\n\t\t\t-- Only change the edited values.\n\t\t\tif NewProperties[Key] then\n\t\t\t\tif ExpectedType and string.lower(typeof(NewProperties[Key])) ~= string.lower(ExpectedType) then\n\t\t\t\t\terror(\"Expected type '\"..ExpectedType..\"' for property '\"..Key..\"', got '\"..typeof(NewProperties[Key])..\"' instead.\");\n\t\t\t\tend;\n\n\t\t\t\tfor _, Instance in pairs(Instances) do\n\t\t\t\t\tlocal s,f = pcall(function()\n\t\t\t\t\t\tInstance[Property] = NewProperties[Key];\n\t\t\t\t\tend);\n\t\t\t\t\tif not s then\n\t\t\t\t\t\twarn(\"Failed to set property '\"..Key..\"' to '\"..tostring(NewProperties[Key])..\"' for instance '\"..Instance.Name..\"'.\");\n\t\t\t\t\tend;\n\t\t\t\tend;\n\t\t\tend;\n\t\tend;\n\tend;\n\n\treturn true;\nend;\n\n-- Cardboard:DestroyAsset( UUID: string ); Returns: Success <boolean>\nfunction Cardboard:DestroyAsset(UUID)\n\tlocal StoredAsset = self:FindAsset(UUID);\n\tlocal Asset = StoredAsset[1];\n\tlocal AssetType = StoredAsset[2];\n\n\tif not Asset then\n\t\treturn false;\n\tend;\n\n\tAsset:Destroy();\n\tCreatedAssets[UUID] = nil;\n\n\treturn true;\nend;\n\n-- Make a meta table for the Cardboard module so it can be accessed like a function, and used as a class as well for the functions. (Cardboard() and Cardboard:FindAsset())\nsetmetatable(Cardboard, {\n\t__call = function(self, ...)\n\t\treturn self.new(...);\n\tend;\n\t__index = Cardboard;\n\t__newindex = function(self, Index:string, Value)\n\t\terror(\"Attempt to modify read-only property '\"..Index..\"'\");\n\tend;\n});\n\nreturn Cardboard;"}},"referenceId":"00000050-bd90-feb6-4f2a-00005ac85e5c","source":"--!strict\n-- Cardboard is the UI handler for NxEngine2; It is responsible for using the existing assets to create a UI for the game.\n-- Otherwise, it can be used for editing existing UIs by checking for a '.cb' module inside the assets which will include the UI structure.\n-- This is the replacement of NanoWorks, which is Nano's UI handler.\n\n-- Template for .cb modules;\n--[[\n    {\n        [Property] = {Table of expected instances, Property, DefaultValue, ExpectedType?};\n    }\n]]\n\n-- Example for a .cb module (Hint module);\n--[[\nreturn {\n\t[\"Title\"] = {\n\t\t{\n\t\t\tscript.Parent.Title;\n\t\t};\n\t\t\"Text\";\n\t\t\"This is a title.\";\n\t\t\"string\";\n\t};\n\t[\"Content\"] = {\n\t\t{\n\t\t\tscript.Parent.Content;\n\t\t};\n\t\t\"Text\";\n\t\t\"This is some content.\";\n\t\t\"string\";\n\t};\n}\n]] --> This is the expected structure for a .cb module. It is a table with the property names as keys, and the values are tables which follow the structure of {Instances, Property, DefaultValue and ExpectedType}.\n\n-- If one does not exist, it will be attempted to be created locally.\n\nlocal Cardboard = {};\n\nlocal Players = game:GetService(\"Players\");\nlocal UserInputService = game:GetService(\"UserInputService\");\nlocal RunService = game:GetService(\"RunService\");\nlocal TweenService = game:GetService(\"TweenService\");\nlocal HttpService = game:GetService(\"HttpService\"); -- Used for JSON encoding/decoding.\nlocal Assets = script:FindFirstAncestorWhichIsA(\"ScreenGui\"):FindFirstChild(\"Assets\");\n\nlocal LocalPlayer = Players.LocalPlayer;\nlocal Mouse = LocalPlayer:GetMouse();\n\nlocal AssetProperties = {}; -- Cache for .cb modules so they won't have to be loaded again.\nlocal CreatedAssets = {}; -- Cache for assets that have been created; Mainly to store used UUIDs.\n\nlocal function CreateUID()\n\tlocal UID = \"\";\n\tfor i = 1, math.random(24, 32) do\n\t\tUID = UID .. string.char(math.random(65, 90));\n\tend\n\treturn UID;\nend\n\n-- Cardboard( AssetType: string, Parent: Instance, [Properties: table] ); Returns: Asset <Instance>, UUID <string>\nfunction Cardboard.new(AssetType, Parent, Properties)\n\t-- Generate a UUID for the asset.\n\tlocal UUID = CreateUID();\n\t\n\tif not Properties then Properties = {}; end;\n\n\tif not Assets:FindFirstChild(AssetType) then\n\t\terror(\"AssetType '\"..AssetType..\"' does not exist in the Assets folder. Does it exist?\");\n\tend;\n\n\t-- Create the asset.\n\tlocal Asset = Assets[AssetType]:Clone();\n\tAsset.Parent = Parent;\n\n\t-- Structure the asset according to the .cb module.\n\tlocal cb = nil;\n\n\tif AssetProperties[UUID] then\n\t\tcb = AssetProperties[UUID];\n\telseif Asset:FindFirstChild(\".cb\") then\n\t\tlocal cbModule = Asset:FindFirstChild(\".cb\");\n\t\tif cbModule and cbModule:IsA(\"ModuleScript\") then\n\t\t\tcb = require(cbModule) :: {[any?]:any?};\n\t\t\tAssetProperties[UUID] = cb;\n\t\tend;\n\tend;\n\n\tif cb then\n\t\tfor Key:string, Data:any in pairs(cb) do\n\t\t\tlocal Instances = Data[1];\n\t\t\tlocal Property = Data[2];\n\t\t\tlocal DefaultValue = Data[3];\n\t\t\tlocal ExpectedType = Data[4];\n\n\t\t\tif not Properties[Key] then\n\t\t\t\tProperties[Key] = DefaultValue;\n\t\t\tend;\n\n\t\t\tif ExpectedType and string.lower(typeof(Properties[Key])) ~= string.lower(ExpectedType) then\n\t\t\t\terror(\"Expected type '\"..ExpectedType..\"' for property '\"..Key..\"', got '\"..typeof(Properties[Key])..\"' instead.\");\n\t\t\tend;\n\n\t\t\tfor _, Instance in pairs(Instances) do\n\t\t\t\tlocal s,f = pcall(function()\n\t\t\t\t\tInstance[Property] = Properties[Key];\n\t\t\t\tend);\n\t\t\t\tif not s then\n\t\t\t\t\twarn(\"Failed to set property '\"..Key..\"' to '\"..tostring(Properties[Key])..\"' for instance '\"..Instance.Name..\"'.\");\n\t\t\t\tend;\n\t\t\tend;\n\t\tend;\n\tend;\n\t\n\t-- Add the asset into the CreatedAssets table.\n\tCreatedAssets[UUID] = {Asset, AssetType};\n\t\n\t-- Make the asset visible.\n\tAsset.Visible = true;\n\n\t-- Return the asset and the UUID.\n\treturn Asset, UUID;\nend;\n\n-- Cardboard:FindAsset( UUID: string ); Returns: StoredAsset <table{Asset, AssetType}>\nfunction Cardboard:FindAsset(UUID)\n\treturn CreatedAssets[UUID] or {nil, \"\"};\nend;\n\n-- Cardboard:UpdateAsset( UUID: string, NewProperties: table ); Returns: Success <boolean>\nfunction Cardboard:UpdateAsset(UUID, NewProperties)\n\tlocal StoredAsset = self:FindAsset(UUID);\n\tlocal Asset = StoredAsset[1];\n\tlocal AssetType = StoredAsset[2];\n\n\tif not Asset then\n\t\treturn false;\n\tend;\n\n\tlocal cb = nil;\n\tif AssetProperties[UUID] then\n\t\tcb = AssetProperties[UUID];\n\telse\n\t\tlocal cbModule = Asset:FindFirstChild(\".cb\");\n\t\tif cbModule and cbModule:IsA(\"ModuleScript\") then\n\t\t\tcb = require(cbModule) :: ModuleScript;\n\t\t\tAssetProperties[UUID] = cb;\n\t\tend;\n\tend;\n\n\tif cb then\n\t\tfor Key:string, Data:any in pairs(cb) do\n\t\t\tlocal Instances = Data[1];\n\t\t\tlocal Property = Data[2];\n\t\t\tlocal DefaultValue = Data[3];\n\t\t\tlocal ExpectedType = Data[4];\n\n\t\t\t-- Only change the edited values.\n\t\t\tif NewProperties[Key] then\n\t\t\t\tif ExpectedType and string.lower(typeof(NewProperties[Key])) ~= string.lower(ExpectedType) then\n\t\t\t\t\terror(\"Expected type '\"..ExpectedType..\"' for property '\"..Key..\"', got '\"..typeof(NewProperties[Key])..\"' instead.\");\n\t\t\t\tend;\n\n\t\t\t\tfor _, Instance in pairs(Instances) do\n\t\t\t\t\tlocal s,f = pcall(function()\n\t\t\t\t\t\tInstance[Property] = NewProperties[Key];\n\t\t\t\t\tend);\n\t\t\t\t\tif not s then\n\t\t\t\t\t\twarn(\"Failed to set property '\"..Key..\"' to '\"..tostring(NewProperties[Key])..\"' for instance '\"..Instance.Name..\"'.\");\n\t\t\t\t\tend;\n\t\t\t\tend;\n\t\t\tend;\n\t\tend;\n\tend;\n\n\treturn true;\nend;\n\n-- Cardboard:DestroyAsset( UUID: string ); Returns: Success <boolean>\nfunction Cardboard:DestroyAsset(UUID)\n\tlocal StoredAsset = self:FindAsset(UUID);\n\tlocal Asset = StoredAsset[1];\n\tlocal AssetType = StoredAsset[2];\n\n\tif not Asset then\n\t\treturn false;\n\tend;\n\n\tAsset:Destroy();\n\tCreatedAssets[UUID] = nil;\n\n\treturn true;\nend;\n\n-- Make a meta table for the Cardboard module so it can be accessed like a function, and used as a class as well for the functions. (Cardboard() and Cardboard:FindAsset())\nsetmetatable(Cardboard, {\n\t__call = function(self, ...)\n\t\treturn self.new(...);\n\tend;\n\t__index = Cardboard;\n\t__newindex = function(self, Index:string, Value)\n\t\terror(\"Attempt to modify read-only property '\"..Index..\"'\");\n\tend;\n});\n\nreturn Cardboard;"}]